<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进学致和，行方思远。</title>
  
  <subtitle>人不过是一尾芦苇,是自然界最脆弱的东西,但人却是一尾能思考的芦苇。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-26T12:23:36.252Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>klaus_turbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos2.x Naming</title>
    <link href="http://example.com/2021/07/07/nacos%E2%80%94naming/"/>
    <id>http://example.com/2021/07/07/nacos%E2%80%94naming/</id>
    <published>2021-07-07T13:55:43.000Z</published>
    <updated>2021-08-26T12:23:36.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅析-Nacos2-x-注册客户端启动流程"><a href="#浅析-Nacos2-x-注册客户端启动流程" class="headerlink" title="浅析 Nacos2.x 注册客户端启动流程"></a>浅析 Nacos2.x 注册客户端启动流程</h1><p>注意：本文所有内容均是基于Nacos2.0.2版本。</p><h4 id="客户端服务注册流程"><a href="#客户端服务注册流程" class="headerlink" title="客户端服务注册流程"></a>客户端服务注册流程</h4><p>Nacos 的服务注册的统一入口在 NamingService 这个接口处定义，通过调用 registerInstance（）方法来注。在 NacosNamingService 处实现了 NamingService 服务注册接口的基础注册方法：registerInstance（）。而实现类的具体实现其实是委托给了 NacosNamingServiceDelegate 这个类去实现的，这个类是比较特殊的，在 1.x 版本是没有的，是在 2.x 版本中新增了 Grpc 之后为了适配原先 1.x 版本的 Nacos-Client 而存在的，在旧版本的客户端中，NacosNamingService 的服务注册请求是直接交给其代理类直接去发送 Http 请求 Server 来实现服务注册的。具体的暂时不做深入。在委托类中，进行 Grpc 和 Http 分流的操作我们可以初窥一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private NamingClientProxy getExecuteClientProxy(Instance instance) &#123;</span><br><span class="line">        return instance.isEphemeral() ? grpcClientProxy : httpClientProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该还是比较易懂的，直接根据服务实例的节点类型来判断，是临时节点的则直接走 GRPC ，否则 Http。<br>在处理 Grpc 请求的代理类 NamingGrpcClientProxy 中 继续调用其 registerService（）方法，然后通过 requestToServer（）封装 Grpc 请求，最后由 GrpcClient 去请求 Nacos-Server 注册服务。至此，Nacos 客户端服务注册的请求流程就走完了。</p><h4 id="服务端服务注册流程"><a href="#服务端服务注册流程" class="headerlink" title="服务端服务注册流程"></a>服务端服务注册流程</h4><p>在客户端将 Grpc 请求丢出来之后，Server 端会通过一个叫 GrpcRequestAcceptor 来接受所有 Grpc 请求（体现了代码规范的重要性，见名知意），通过调用其定义的 request 方法，根据请求 type 来从请求处理器注册中心中获取对应的请求处理器来处理请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestHandler requestHandler &#x3D; requestHandlerRegistry.getByRequestType(type);</span><br></pre></td></tr></table></figure><p>RequestHandlerRegistry 是一个托管给 Spring 的 Bean ，在容器启动刷新之后，其会将所有继承了标注基类 RequestHandler 的 Bean 注入其内部的 Map 缓存，用各个 Bean 的 Type 做抽象工厂 Bean 获取标识。当然，此处由于我们的请求是用于处理服务注册（type = registerInstance）的，所以我们会在 InstanceRequestHandler 中去处理，调用 registerInstance（）来处理，值得注意的是，这里的服务由于是临时节点，会调用 EphemeralClientOperationServiceImpl 类去做最后的处理。到这，服务端的服务注册请求就处理完毕了。</p><p>在基于简化流程分析之后，相信大家对于 Nacos 的注册流程有了一个大体的概念了。不难发现与旧版本 1.x 的不同点之一便是多了很多的扩展代码，如客户端的 NacosNamingServiceDelegate 用来扩展协议，服务端的 GrpcRequestAcceptor 用来分发请求，扩展请求类型，RequestHandlerRegistry 工厂则是隐式的扩展了请求处理器。设计模式如此之重要。值得一提的是，1.x 版本的 Nacos 是基于内核化思想实现的，新版本的 2.x 版本是基于插件化思想实现的，值得大家琢磨学习，架构思想是如何实现的，这也是所谓的源码之道。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>在看了基础流程介绍之后，我们将会进入到一段相对枯涩的阶段：源码解析</p><p>我们将会基于我们的流程，分为以下几个趴分别去解释 Nacos 到底做了什么：</p><ul><li>NamingService 实现类以及其委托代理类初始化流程</li><li>从服务信息通知过程来了解贯穿整个Nacos的NotifyCenter是如何运行的</li></ul><p>一般的，我们会通过一个工厂方法 NamingFactory，来创建我们的 NamingService 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line"></span><br><span class="line">properties.setProperty(&quot;serverAddr&quot;, &quot;127.0.0.1:8848&quot;); </span><br><span class="line"></span><br><span class="line">NamingService naming &#x3D; NamingFactory.createNamingService(properties);</span><br></pre></td></tr></table></figure><p>在创建实例的时候我们会传入一个 Properties 对象到我们的 NamingService 的构造方法中，来初始化我们的 NamingService 对象。我们看一下其实现类 NacosNamingService 的构造函数是怎么处理的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public NacosNamingService(Properties properties) throws NacosException &#123;</span><br><span class="line">       init(properties);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void init(Properties properties) throws NacosException &#123;</span><br><span class="line">       ValidatorUtils.checkInitParam(properties); &#x2F;&#x2F; 1 检查 ContextPath 的合法性</span><br><span class="line">       this.namespace &#x3D; InitUtils.initNamespaceForNaming(properties); &#x2F;&#x2F; 2 初始化 namespace</span><br><span class="line">       InitUtils.initSerialization(); &#x2F;&#x2F; 3 主要是为了序列化安全</span><br><span class="line">       InitUtils.initWebRootContext(properties); &#x2F;&#x2F; 4 初始化 contextPath</span><br><span class="line">       initLogName(properties); &#x2F;&#x2F; 5 初始化日志前缀名称</span><br><span class="line">       </span><br><span class="line">       this.changeNotifier &#x3D; new InstancesChangeNotifier(); &#x2F;&#x2F; 6</span><br><span class="line">       NotifyCenter.registerToPublisher(InstancesChangeEvent.class, 16384); &#x2F;&#x2F; 7</span><br><span class="line">       NotifyCenter.registerSubscriber(changeNotifier); &#x2F;&#x2F; 8</span><br><span class="line">       this.serviceInfoHolder &#x3D; new ServiceInfoHolder(namespace, properties); &#x2F;&#x2F; 9</span><br><span class="line">       this.clientProxy &#x3D; new NamingClientProxyDelegate(this.namespace, serviceInfoHolder, properties, changeNotifier); &#x2F;&#x2F; 10</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们依次来看看，NacosNamingService 构造函数调用了一个 init（）方法，其中主要做了 11 件事情。其中，我们主要看后面五个。<br>首先看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.changeNotifier &#x3D; new InstancesChangeNotifier(); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><p>这里会新 new 一个 InstancesChangeNotifier 对象，见名知意，大概猜出它是用于实例变更的通知的，这一步我们在初始化流程中先不做详细分析，在后面会单独出来一个章节去解释这个 NotifyCenter 和 一系列的Notifier,Subscriber的妙用。抛开业务流程，这部分个人觉得还是可以品一下的。</p><p>好，那这样我们就直接跳到 init() 方法的最后两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化 ServiceInfoHolder</span><br><span class="line">this.serviceInfoHolder &#x3D; new ServiceInfoHolder(namespace, properties);</span><br><span class="line">&#x2F;&#x2F; 初始化 NamingClientProxyDelegate</span><br><span class="line">this.clientProxy &#x3D; new NamingClientProxyDelegate(this.namespace, serviceInfoHolder, properties, changeNotifier);</span><br></pre></td></tr></table></figure><p>看一下 ServiceInfoHolder ，这里就体现了命名规范的重要性了，我们还是可以使用那个词 – 见明知意，这个是一个服务信息的持有者，在我们将我们的服务注册到 Nacos 上之后，那么这个类将是我们交互访问最多的一个类。它的主要工作内容就是负责缓存，本地化服务信息以及预防故障的冗余处理，来看一下它比较重要的两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于缓存</span><br><span class="line">private final ConcurrentMap&lt;String, ServiceInfo&gt; serviceInfoMap;</span><br><span class="line">&#x2F;&#x2F; 用于故障冗余</span><br><span class="line">private final FailoverReactor failoverReactor;</span><br></pre></td></tr></table></figure><p>不难看出，ServiceInfoHolder 主要做的事情就是对服务信息的缓存以及故障冗余。<br>下面再来看一下他的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ServiceInfoHolder(String namespace, Properties properties) &#123;</span><br><span class="line">       initCacheDir(namespace, properties);</span><br><span class="line">       &#x2F;&#x2F; 判断是否需要在启动的时候读取缓存的配置</span><br><span class="line">       if (isLoadCacheAtStart(properties)) &#123;</span><br><span class="line">           this.serviceInfoMap &#x3D; new ConcurrentHashMap&lt;String, ServiceInfo&gt;(DiskCache.read(this.cacheDir));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.serviceInfoMap &#x3D; new ConcurrentHashMap&lt;String, ServiceInfo&gt;(16);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 初始化一个 FailoverReactor</span><br><span class="line">       this.failoverReactor &#x3D; new FailoverReactor(this, cacheDir);</span><br><span class="line">       &#x2F;&#x2F; 判断是否配置了空消息推送保护，开启了的时候在服务端推送错误或者空的服务信息的时候&#x2F;&#x2F; 会忽略.</span><br><span class="line">       this.pushEmptyProtection &#x3D; isPushEmptyProtect(properties);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很简单，初始化了 Map 和故障切换，还有就是根据配置判断是否需要忽略服务端无效的推送信息。</p><p>最后一步，当然也是决定我们是否真的能够执行注册订阅等请求的一个类 – NamingClientProxy 在这开始登场，这个类的作用其实就是一个我们客户端中 1.x 和 2.x 的请求的适配和分发。我们知道，在 1.x 和 2.x 两个版本迭代的最大区别之一便是客户端服务端之间请求方式的改变，从原本的 http 优化到了 grpc 的请求形式。由于我们分析的主要是 2.x 的版本，所以客户端服务端均是默认 grpc 。当然，对于低版本客户端连接高版本服务端是可以兼容的，但反过来就不行了。</p><p>来，直接看一下 NamingClientProxyDelegate 的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public NamingClientProxyDelegate(String namespace, ServiceInfoHolder serviceInfoHolder, Properties properties,</span><br><span class="line">            InstancesChangeNotifier changeNotifier) throws NacosException &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化一个ServiceInfo更新的服务</span><br><span class="line">        this.serviceInfoUpdateService &#x3D; new ServiceInfoUpdateService(properties, serviceInfoHolder, this,</span><br><span class="line">                changeNotifier);</span><br><span class="line">        &#x2F;&#x2F; 初始化 服务端地址管理的服务        </span><br><span class="line">        this.serverListManager &#x3D; new ServerListManager(properties, namespace);</span><br><span class="line">        &#x2F;&#x2F; 将 NacosNamingService 传递过来的 ServiceInfoHolder 指向自己内部的 ServiceInfoHolder.</span><br><span class="line">        this.serviceInfoHolder &#x3D; serviceInfoHolder;</span><br><span class="line">        &#x2F;&#x2F; 安全管理</span><br><span class="line">        this.securityProxy &#x3D; new SecurityProxy(properties,</span><br><span class="line">                NamingHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line">        initSecurityProxy();</span><br><span class="line">        &#x2F;&#x2F; 初始化Http方式的请求服务</span><br><span class="line">        this.httpClientProxy &#x3D; new NamingHttpClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br><span class="line">        &#x2F;&#x2F; 初始化Grpc方式的请求服务</span><br><span class="line">        this.grpcClientProxy &#x3D; new NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们直接一起看第一行和最后一行，中间的部分操作对于我们分析 2.x 的业务流程可以省略，有兴趣的读者可以自行去翻阅源码，首先看的是这个叫做 ServiceInfoUpdateService 的服务的作用。直接去到他的构造函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ServiceInfoUpdateService(Properties properties, ServiceInfoHolder serviceInfoHolder,</span><br><span class="line">            NamingClientProxy namingClientProxy, InstancesChangeNotifier changeNotifier) &#123;</span><br><span class="line">        this.executor &#x3D; new ScheduledThreadPoolExecutor(initPollingThreadCount(properties),</span><br><span class="line">                new NameThreadFactory(&quot;com.alibaba.nacos.client.naming.updater&quot;));</span><br><span class="line">        this.serviceInfoHolder &#x3D; serviceInfoHolder;</span><br><span class="line">        this.namingClientProxy &#x3D; namingClientProxy;</span><br><span class="line">        this.changeNotifier &#x3D; changeNotifier;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在构造器中初始化了一个用于任务调度的线程池 – ScheduledThreadPoolExecutor ，在向 ServiceInfoUpdateService 的 scheduleUpdateIfAbsent() 方法的时候便会使用这个内部的线程池去做一些更新注册服务相关的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleUpdateIfAbsent(String serviceName, String groupName, String clusters) &#123;</span><br><span class="line">        String serviceKey &#x3D; ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);</span><br><span class="line">        if (futureMap.get(serviceKey) !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (futureMap) &#123;</span><br><span class="line">            if (futureMap.get(serviceKey) !&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ScheduledFuture&lt;?&gt; future &#x3D; addTask(new UpdateTask(serviceName, groupName, clusters));</span><br><span class="line">            futureMap.put(serviceKey, future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private synchronized ScheduledFuture&lt;?&gt; addTask(UpdateTask task) &#123;</span><br><span class="line">        return executor.schedule(task, DEFAULT_DELAY, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在更新任务 UpdateTask 的run() 方法中，更新的对象便是我们之前分析的 ServiceInfoHolder 。</p><p>再来看 NamingGrpcClientProxy ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.grpcClientProxy &#x3D; new NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br></pre></td></tr></table></figure><p>这段代码主要便是初始化 NamingGrpcClientProxy 这个 Grpc 请求的执行类，期间涉及到 Rpc 初始化和启动的流程，其内容篇幅比较长，我们会在后面单独起一个章节去分析，在这我们先简单看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造器</span><br><span class="line">public NamingGrpcClientProxy(String namespaceId, SecurityProxy securityProxy, ServerListFactory serverListFactory,</span><br><span class="line">            Properties properties, ServiceInfoHolder serviceInfoHolder) throws NacosException &#123;</span><br><span class="line">        super(securityProxy, properties);</span><br><span class="line">        this.namespaceId &#x3D; namespaceId;</span><br><span class="line">        &#x2F;&#x2F; 用于标识一个 RpcClient</span><br><span class="line">        this.uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">        &#x2F;&#x2F; rpc请求超时时间</span><br><span class="line">        this.requestTimeout &#x3D; Long.parseLong(properties.getProperty(CommonParams.NAMING_REQUEST_TIMEOUT, &quot;-1&quot;));</span><br><span class="line">        Map&lt;String, String&gt; labels &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">        labels.put(RemoteConstants.LABEL_SOURCE, RemoteConstants.LABEL_SOURCE_SDK);</span><br><span class="line">        labels.put(RemoteConstants.LABEL_MODULE, RemoteConstants.LABEL_MODULE_NAMING);</span><br><span class="line">        &#x2F;&#x2F; 创建一个 RpcClient 用于 Rpc 请求</span><br><span class="line">        this.rpcClient &#x3D; RpcClientFactory.createClient(uuid, ConnectionType.GRPC, labels);</span><br><span class="line">        &#x2F;&#x2F; 在 RpcClient 中会有链接结果的回调，这里是将自己注册到对应的 Linstener 中，用于相关事件发生时的回调</span><br><span class="line">        this.namingGrpcConnectionEventListener &#x3D; new NamingGrpcConnectionEventListener(this);</span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        start(serverListFactory, serviceInfoHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rpc请求客户端的启动，我们放在后面分析</span><br><span class="line">private void start(ServerListFactory serverListFactory, ServiceInfoHolder serviceInfoHolder) throws NacosException &#123;</span><br><span class="line">        rpcClient.serverListFactory(serverListFactory);</span><br><span class="line">        rpcClient.start();</span><br><span class="line">        &#x2F;&#x2F; 向 RpcClient 注册一个用于处理服务端推送的 Handler</span><br><span class="line">        rpcClient.registerServerRequestHandler(new NamingPushRequestHandler(serviceInfoHolder));</span><br><span class="line">        &#x2F;&#x2F; 向 RpcClient 注册一个用于连接建立与断开的监听器</span><br><span class="line">        rpcClient.registerConnectionListener(namingGrpcConnectionEventListener);</span><br><span class="line">        &#x2F;&#x2F; 向消息中心注册自己</span><br><span class="line">        NotifyCenter.registerSubscriber(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程的目的是比较清晰的，初始化一个带有特殊标记（uuid）的 rpcClient ，这个 rpcClient 将负责后续所有的 Grpc 请求。其中，事件注册占这中间代码量的近一半，确实，Nacos 自己定义的这一套内部的事件处理流程很意思，实现了基于 EDA 与 观察者模式的事件架构，个人比较喜欢这一块的思想，我们也会在后续起一个章节去分析他是如何通过自己内部的这个 NotifyCenter 来解耦繁多的应用组件的。</p><p>到这，Nacos 注册客户端启动流程就基本结束了，后续的 API 操作便是依托在这个流程之上来运行的。期间断断续续的再写，有很多讲的不到位的地方。这是我们整个 Nacos 旅程的开胃菜，我们会在后面的章节中慢慢的一点点的去啃食，RpcClient怎么启动的？NotifyCenter是如何工作的？等等一系列的疑问我们会慢慢分析。</p><p>总结，答题的流程是比较简单的，内容大体如下图：</p><p><img src="/images/nacos_Client%E6%B3%A8%E5%86%8C%E9%83%A8%E5%88%86%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="流程图"></p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浅析-Nacos2-x-注册客户端启动流程&quot;&gt;&lt;a href=&quot;#浅析-Nacos2-x-注册客户端启动流程&quot; class=&quot;headerlink&quot; title=&quot;浅析 Nacos2.x 注册客户端启动流程&quot;&gt;&lt;/a&gt;浅析 Nacos2.x 注册客户端启动流程&lt;/</summary>
      
    
    
    
    <category term="Nacos" scheme="http://example.com/categories/Nacos/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
    <category term="注册中心" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Springboot自动装配</title>
    <link href="http://example.com/2020/11/21/springboot_autowired/"/>
    <id>http://example.com/2020/11/21/springboot_autowired/</id>
    <published>2020-11-21T05:55:34.000Z</published>
    <updated>2021-08-26T12:23:36.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关知识介绍"><a href="#相关知识介绍" class="headerlink" title="相关知识介绍"></a>相关知识介绍</h2><p>首先我们先来简单认识一下 @Import 这个注解。@Import注解支持将普通的<br>Java 类注入进容器里面，将其声明称一个 bean，可以将多个 Java Config 配置类融合称一个更大的 Config 类。<br>在 spring 4.2 之前，@Import 只支持导入配置类，但在 4.2 之后 @Import 注解支持导入普通的 Java 类，并将其声明称一个 bean。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>直接导入普通的 Java 类</li><li>配合自定义的 ImportSelector 使用</li><li>配合 ImportBeanDefinitionRegister 使用</li></ol><h4 id="直接导入普通-Java-类"><a href="#直接导入普通-Java-类" class="headerlink" title="直接导入普通 Java 类"></a>直接导入普通 Java 类</h4><p>我们先简单创建一个 Springboot 应用：</p><p><img src="/images/springboot_app.png" alt="springboot_app.png"></p><p>其中 Application 是主配置类，ImportHelloWorld 是我们的测试类。<br>看一下其中代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImportHelloWorld implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化ImportHelloWorld...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 InitializingBean 用于在当前类被容器初始化之后做一些事情，在这里我们是直接打印了一句话。在主配置类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Import(ImportHelloWorld.class)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接使用 @Import 注解来将我们的 ImportHelloWorld 注入容器之内，来看一下启动后的控制台信息：</p><p><img src="/images/springboot_demo001.png" alt="springboot_demo001.png"></p><p>可以看到我们的注解方式生效了，并成功的将 bean 初始化之后的信息输出到了控制台上。</p><h4 id="使用自定义的-ImportSelector"><a href="#使用自定义的-ImportSelector" class="headerlink" title="使用自定义的 ImportSelector"></a>使用自定义的 ImportSelector</h4><p>我们首先还是自定义一个 Java 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ImportSelectorHelloWorld implements InitializingBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化 ImportSelectorHelloWorld ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上面同样的方式，使其可以在被加载之后可以输出一些标示性的话，其次是我们自定义一个我们自己的 ImportSelector 用于注册我们定义的 ImportSelectorHelloWorld ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;xyz.turboklaus.spring.ImportSelectorHelloWorld&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方法返回了一个 String 类型的数组，在数组中我们将定义好的 ImportSelectorHelloWorld 的包地址放进去，然后我们使用 @Import 将 MyImportSelector 注入容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;ImportHelloWorld.class,MyImportSelector.class&#125;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloWorldProperties properties;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动后控制台的输出信息：</p><p><img src="/images/springboot_demo002.png" alt="springboot_demo002.png"><br>成功的输出了我们定义的信息。</p><h4 id="配合自定义的-ImportBeanDefinitionRegistrar"><a href="#配合自定义的-ImportBeanDefinitionRegistrar" class="headerlink" title="配合自定义的 ImportBeanDefinitionRegistrar"></a>配合自定义的 ImportBeanDefinitionRegistrar</h4><p>不多说，直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义 Java 类</span><br><span class="line">public class ImportBeanDefinitionRegistryHelloWorld implements InitializingBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化 ImportBeanDefinitionRegistryHelloWorld ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义 ImportBeanDefinitionRegistrar</span><br><span class="line">public class MyImportBeanDefinitionRegistry implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        RootBeanDefinition definition &#x3D; new RootBeanDefinition(ImportBeanDefinitionRegistryHelloWorld.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;importBeanDefinitionRegistryHelloWorld&quot;, definition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注入 MyImportBeanDefinitionRegistry</span><br><span class="line">@Import(&#123;ImportHelloWorld.class,MyImportSelector.class,MyImportBeanDefinitionRegistry.class&#125;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看运行结果：</p><p><img src="/images/springboot_demo003.png" alt="springboot_demo003.png"></p><p>成功输出。</p><h2 id="主题-Springboot自动配置原理"><a href="#主题-Springboot自动配置原理" class="headerlink" title="主题 - - Springboot自动配置原理"></a>主题 - - Springboot自动配置原理</h2><h3 id="SpringbootApplication"><a href="#SpringbootApplication" class="headerlink" title="@SpringbootApplication"></a>@SpringbootApplication</h3><p>一切的一切都要归根到这里，从 @SpringbootApplication 注解开始说起。</p><p>@SpringBootApplication 标注在某个类上说明：</p><ul><li>这个类是 Springboot 的主配置类</li><li>Springboot 就应该运行这个类的 main 方法来启动 Springboot应用</li></ul><p>看一下这个注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters &#x3D; &#123;@Filter(</span><br><span class="line">    type &#x3D; FilterType.CUSTOM,</span><br><span class="line">    classes &#x3D; &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type &#x3D; FilterType.CUSTOM,</span><br><span class="line">    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出 @SpringbootApplication 是一个组合注解</p><ul><li>@SpringBootConfiguration：该注解表示这是一个 SpringBoot 的配置类，其实它就是一个 @Configuration 注解</li><li>@ComponentScan：开启组件扫描</li><li>@EnableAutoConfiguration：从名字就可以看出来，就是这个类开启自动配置的。嗯，自动配置的奥秘全都在这个注解里面</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>我们先来看一下它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>从它的取名可以看出这大概是一个用于自动配置包的注解，我们继续看它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终于我们看到了比较熟悉的一个注解 @Import 其中它注入了一个叫 Registrar 的类。我们在其方法上打上一个断点然后启动应用：</p><p><img src="/images/springboot_demo004.png" alt="springboot_demo004.png"></p><p>输出了我们主配置类所在包的包名。简而言之，@AutoConfigurationPackage 注解就是将主配置类所在包以及下面的所有子包里面的所有组件扫描到 Spring 容器之中，所以说，默认情况下，主配置类包以及子包之外的组件，Spring是扫描不到的。</p><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>这个注解的作用就是给当前的配置类导入另外的别的自动配置类。@Import 注入的 AutoConfigurationImportSelector ，我们通过前面 @Import 的例子知道， selectimport 就是用来返回我们需要导入的组件的全类名的数组，就如同下面方法所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return NO_IMPORTS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry &#x3D; this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下其大概的调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return EMPTY_ENTRY;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AnnotationAttributes attributes &#x3D; this.getAttributes(annotationMetadata);</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">            List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations &#x3D; this.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions &#x3D; this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations &#x3D; this.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">        List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用链大概如上1-2-3所示，其中第三步调用 SpringFactoriesLoader.loadFactoryNames 中比较关键的三步：</p><ul><li>从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</li><li>将上面获取到的信息封装成一个 Map 返回。</li><li>从返回的 Map 中通过刚才传入的 EnableAutoConfiguration.class 参数，获取该 key 下的所有值。</li></ul><p>其中的第一步就是将类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到 Spring 容器中。</p><p>至此Springboot的自动配置就完成了，其比较重要的一个文件就是  META-INF/spring.factories 。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关知识介绍&quot;&gt;&lt;a href=&quot;#相关知识介绍&quot; class=&quot;headerlink&quot; title=&quot;相关知识介绍&quot;&gt;&lt;/a&gt;相关知识介绍&lt;/h2&gt;&lt;p&gt;首先我们先来简单认识一下 @Import 这个注解。@Import注解支持将普通的&lt;br&gt;Java 类注入进</summary>
      
    
    
    
    <category term="Springboot" scheme="http://example.com/categories/Springboot/"/>
    
    
    <category term="Springboot" scheme="http://example.com/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Netty-ChannelPipeline，ChannelHandler和ChannelHandlerContext</title>
    <link href="http://example.com/2020/10/27/channelpipeline-channelhandler-channelhandlercontext/"/>
    <id>http://example.com/2020/10/27/channelpipeline-channelhandler-channelhandlercontext/</id>
    <published>2020-10-27T06:55:48.000Z</published>
    <updated>2021-08-26T12:23:36.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是ChannelPipeline？"><a href="#什么是ChannelPipeline？" class="headerlink" title="什么是ChannelPipeline？"></a>什么是ChannelPipeline？</h3><p>抽象的来说，ChannelPipeline是一个拦截或者处理 Channel 的入站和出站事件的 ChannelHandler 实例链。</p><p>具象的来说，ChannelPipeline是ChannelHandler的容器，负责管理ChannelHandler和事件的调度与拦截。</p><p>ChannelPipeline提供了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式以及ChannelPipeline中的ChannelHandlers如何进行交互。</p><p>对于每一个Channel来说，Netty会为其单独创建一个ChannelPipeline并将其与该创建的Pipeline绑定。绑定后，Channel与ChannelPipeline之间的耦合是永久的。Channel不能绑定另一条ChannelPipeline或者将当前已经绑定的ChannelPipeline与自己捆绑。当然这些个操作Netty已经帮我们做好了。</p><p>我们来看下面这一张图：<br><img src="/images/netty_pipeline.png" alt="netty_pipeline.png"></p><p>图内标注了 InboundHandler 和 OutbountHandler ，表示在ChannelPipeline 中的消息流转是有方向的。同时也展示出了这入站和出站的来源。通常来说，InboundHandler 处理由图中底部由Netty内部I/O产生的入站数据。一个入站的I/O事件将从底部向上传播，出站的I/O事件将从上往下传播，通常Netty将入站开始的地方称为头部，出站开始的地方称为尾部。</p><p>在 ChannelPipeline 传播事件时，它会判断 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。(当然，ChannelHandler 也可以同时实现 ChannelInboundHandler 接口和 ChannelOutboundHandler 接口。)</p><h4 id="ChannelPipeline源码分析"><a href="#ChannelPipeline源码分析" class="headerlink" title="ChannelPipeline源码分析"></a>ChannelPipeline源码分析</h4><p>首先来看一下ChannelPipeline的类关系图：</p><p><img src="/images/netty_channel_pipeline_class.png" alt="netty_channel_pipeline_class.png"></p><p>它的继承关系十分的简单，直接实现类也就只有一个DefaultChannelPipeline。由于ChannelPipeline的自身操作主要集中在链的操作上面，而一些例如传播事件等都是通过转发的操作进行的，我们就着重分析其链的操作。</p><p>几个常用的操作大概有下面这几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline addFirst(String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addLast(String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline remove(ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);</span><br></pre></td></tr></table></figure><p>从方法名字应该不难看出这些方法的作用吧。添加的方法我们这里就来分析一个addBefore（），来看一下它的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline addBefore(</span><br><span class="line">            EventExecutorGroup group, String baseName, String name, ChannelHandler handler) &#123;</span><br><span class="line">        final AbstractChannelHandlerContext newCtx;</span><br><span class="line">        final AbstractChannelHandlerContext ctx;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 做重复校验</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line">            name &#x3D; filterName(name, handler);</span><br><span class="line">            &#x2F;&#x2F; 通过名字获取ctx实例</span><br><span class="line">            ctx &#x3D; getContextOrDie(baseName);</span><br><span class="line">            &#x2F;&#x2F; 新增ChannelHandler</span><br><span class="line">            newCtx &#x3D; newContext(group, name, handler);</span><br><span class="line">            addBefore0(ctx, newCtx);</span><br><span class="line">            if (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, true);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor &#x3D; newCtx.executor();</span><br><span class="line">            if (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于ChannelPipeline支持运行期的动态修改，所以可能存在I/O线程与用户线程的并发访问或者是多个用户线程的并发访问。所以在方法内部使用了同步块。</p><p>重复性校验主要的作用是检查当前加入进来的ChannelHandler已经加进来了了，若已经加入那么这个Handler是否使用了@Sharable注解注释了，否则将会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void checkMultiplicity(ChannelHandler handler) &#123;</span><br><span class="line">        if (handler instanceof ChannelHandlerAdapter) &#123;</span><br><span class="line">            ChannelHandlerAdapter h &#x3D; (ChannelHandlerAdapter) handler;</span><br><span class="line">            if (!h.isSharable() &amp;&amp; h.added) &#123;</span><br><span class="line">                throw new ChannelPipelineException(</span><br><span class="line">                        h.getClass().getName() +</span><br><span class="line">                                &quot; is not a @Sharable handler, so can&#39;t be added or removed multiple times.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            h.added &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后是通过filterName（）这个方法对当前要添加的handler进行取名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private String filterName(String name, ChannelHandler handler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 无名字则生成一个</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return generateName(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断名字是否重复</span><br><span class="line">        checkDuplicateName(name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是核心方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx &#x3D; getContextOrDie(baseName);</span><br><span class="line">         </span><br><span class="line">newCtx &#x3D; newContext(group, name, handler);</span><br></pre></td></tr></table></figure><p>首先是通过getContextOrDie（）方法获取当前handler添加的后一个handler的handlerContext。addBefore方法针对两个handler，一个是我们要添加的handler，另一个是已经添加进去的那个handler，在方法中的表述就是newCtx和ctx。来看一下获取ctx（我们要添加进去的handler的后一个handler的handlerContext）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"> private AbstractChannelHandlerContext getContextOrDie(String name) &#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx &#x3D; (AbstractChannelHandlerContext) context(name);</span><br><span class="line">        if (ctx &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NoSuchElementException(name);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ctx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"> public final ChannelHandlerContext context(String name) &#123;</span><br><span class="line">        return context0(ObjectUtil.checkNotNull(name, &quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line"> private AbstractChannelHandlerContext context0(String name) &#123;</span><br><span class="line">        AbstractChannelHandlerContext context &#x3D; head.next;</span><br><span class="line">        while (context !&#x3D; tail) &#123;</span><br><span class="line">            if (context.name().equals(name)) &#123;</span><br><span class="line">                return context;</span><br><span class="line">            &#125;</span><br><span class="line">            context &#x3D; context.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取ctx的主要看方法3，由于在初始化的时候pipeline定义了一个头和尾，所以我们可以看到在获取的时候我们总是去除了头尾，遍历context链表，直到有匹配的。<br>回到方法1，若我们没有匹配到传入的name，则会抛出一个NoSuchElementException异常。反之则返回ctx。<br>对于新的context，是通过调用了Contex构造方法来产生一个新的context，这个方法在几个添加handler的方法中是差不多的，这就是“每当handler加入到pipeline中的时候就会生成一个对应的contex”。<br>然后是正式的将我们构造好的context加入到当前的context链中去的操作，通过方法addBefore0（）实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void addBefore0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) &#123;</span><br><span class="line">        newCtx.prev &#x3D; ctx.prev;</span><br><span class="line">        newCtx.next &#x3D; ctx;</span><br><span class="line">        ctx.prev.next &#x3D; newCtx;</span><br><span class="line">        ctx.prev &#x3D; newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是普通的链表操作，当前context持有的前后context引用的变换。</p><p>接着看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">if (!registered) &#123;</span><br><span class="line">        newCtx.setAddPending();</span><br><span class="line">        callHandlerCallbackLater(newCtx, true);</span><br><span class="line">        return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是代码块1，这里对Channel是否已经注册到Eventloop进行了判断，若未注册，将handler的状态由INIT–&gt;ADD_PENDING，并将添加Handler这个事件加入到一个专门处理延迟事件的链表中（Channel注册后需要处理的任务）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) &#123;</span><br><span class="line">       assert !registered;</span><br><span class="line">       &#x2F;&#x2F; 判断是否是添加handler的事件</span><br><span class="line">       PendingHandlerCallback task &#x3D; added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx);</span><br><span class="line">       PendingHandlerCallback pending &#x3D; pendingHandlerCallbackHead;</span><br><span class="line">       if (pending &#x3D;&#x3D; null) &#123;</span><br><span class="line">           pendingHandlerCallbackHead &#x3D; task;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 将当前task加入链尾</span><br><span class="line">           while (pending.next !&#x3D; null) &#123;</span><br><span class="line">               pending &#x3D; pending.next;</span><br><span class="line">           &#125;</span><br><span class="line">           pending.next &#x3D; task;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看一下这个task的真面目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">private abstract static class PendingHandlerCallback implements Runnable &#123;</span><br><span class="line">        final AbstractChannelHandlerContext ctx;</span><br><span class="line">        PendingHandlerCallback next;</span><br><span class="line"></span><br><span class="line">        PendingHandlerCallback(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">            this.ctx &#x3D; ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        abstract void execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现类</span><br><span class="line">private final class PendingHandlerAddedTask extends PendingHandlerCallback &#123;</span><br><span class="line">        PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">            super(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        void execute() &#123;</span><br><span class="line">            EventExecutor executor &#x3D; ctx.executor();</span><br><span class="line">   &#x2F;&#x2F; 判断执行的线程是否是原本分配的线程</span><br><span class="line">            if (executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAdded0(ctx);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">&#x2F;&#x2F; 执行callHandlerAdded0(ctx)</span><br><span class="line">                    executor.execute(this);</span><br><span class="line">                &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">                    if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(</span><br><span class="line">                                &quot;Can&#39;t invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;.&quot;,</span><br><span class="line">                                executor, ctx.name(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">&#x2F;&#x2F; 事件执行异常，将新加的handlerContext从列表中移除</span><br><span class="line">                    atomicRemoveFromHandlerList(ctx);</span><br><span class="line">&#x2F;&#x2F;设置handler的状态为REMOVE_COMPLETE</span><br><span class="line">                    ctx.setRemoved();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就是其添加的时候定义的一个task，来看这个task执行的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ctx.callHandlerAdded();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">           &#x2F;&#x2F; ...省略异常之后handler的移除操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">final void callHandlerAdded() throws Exception &#123;</span><br><span class="line">        if (setAddComplete()) &#123;</span><br><span class="line">            handler().handlerAdded(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3 设置handler的状态为ADD_COMPLETE</span><br><span class="line"> final boolean setAddComplete() &#123;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            int oldState &#x3D; handlerState;</span><br><span class="line">            if (oldState &#x3D;&#x3D; REMOVE_COMPLETE) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>task的内容主要是通知这个handler被加进来了。<br>在方法2中，我们必须在调用handlerAdded之前调用setAddComplete。<br>否则，如果handlerAdded方法生成任何pipeline事件ctx.handler（）都会错过它们，因为状态不允许。</p><p>以上是对当前Channel还未注册到Eventloop是的处理，若已经注册了，则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventExecutor executor &#x3D; newCtx.executor();</span><br><span class="line">if (!executor.inEventLoop()) &#123;</span><br><span class="line">         callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">         return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取绑定的exector，再判断这个excutor是否是自己注册时候绑定的eventloop（），若是，则继续执行上面的callHandlerAdded0（）方法去通知这个handler已经添加了，若不是channel注册时候绑定的那个eventloop，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerAddedInEventLoop(final AbstractChannelHandlerContext newCtx, EventExecutor executor) &#123;</span><br><span class="line">        newCtx.setAddPending();</span><br><span class="line">        executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                callHandlerAdded0(newCtx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这了你会发现怎么这么眼熟，没错，这里就是用exector去执行了handler添加通知的事情，和上面一样的操作。</p><p>addBefore的分析到这就结束了，由于其他的一些操作与这个都是大同小异，对于其他的操作这里就不自赘述了，至此，ChannelPipeline就分析结束了。</p><h3 id="什么是ChannelHandler？"><a href="#什么是ChannelHandler？" class="headerlink" title="什么是ChannelHandler？"></a>什么是ChannelHandler？</h3><p>正如上一小节所说的ChannelHandler是用于拦截或者处理Channel的入站和出站事件的。它可以选择性的拦截和处理自己感兴趣的事件，也可以通过透传和终止事件的传递。基于ChannelHandler接口，用户可以方便的进行业务逻辑定制，例如打印日志，统一封装异常信息，性能统计和消息编解码等。</p><p>ChannelHandler支持两种注解：</p><ul><li>Sharable：允许多个ChannelPipeLine共用同一个ChannelHandler。</li><li>Skip：被Skip注解的方法不会被调用，直接忽略掉</li></ul><p>根据入站和出站的不同，Netty将ChannelHandler扩展了两个重要的子类：</p><ul><li>ChannelInboundHandler：负责处理入站的数据以及各种状态变化</li><li>ChannelOutboundHandler：负责处理出站的数据并且允许拦截所有的数据</li></ul><p>ChannelHandler和ChannelPipeline的关系如下图所示：</p><p><img src="/images/netty_channle_pipeline_in_out.png" alt="netty_channle_pipeline_in_out.png"></p><h3 id="什么是ChannelHandlerContext？"><a href="#什么是ChannelHandlerContext？" class="headerlink" title="什么是ChannelHandlerContext？"></a>什么是ChannelHandlerContext？</h3><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。</p><p>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 ChannelPipeline 本身上，但是有一点重要的不同。如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。 而调用位于 ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler。</p><p>值得注意的是：</p><ul><li><p>ChannelHandlerContext 和 ChannelHandler 之间的关联(绑定)是永远不会改变的，所以缓存对它的引用是安全的;</p></li><li><p>如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</p></li></ul><p>Channel，ChannelPipeline，ChannelHandler和ChannelHandlerContext四者之间的关系如下：</p><p><img src="/images/netty_channel_handler_process.png" alt="netty_channel_handler_process.png"></p><p>ChannelHandler，ChannelPipeline和ChannelHandlerContext三者的对应关系如下：</p><p><img src="/images/netty_handler_context_pipeline_relation.png" alt="netty_handler_context_pipeline_relation.png"></p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是ChannelPipeline？&quot;&gt;&lt;a href=&quot;#什么是ChannelPipeline？&quot; class=&quot;headerlink&quot; title=&quot;什么是ChannelPipeline？&quot;&gt;&lt;/a&gt;什么是ChannelPipeline？&lt;/h3&gt;&lt;p&gt;抽象</summary>
      
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>Netty-Channel</title>
    <link href="http://example.com/2020/10/21/netty-channel/"/>
    <id>http://example.com/2020/10/21/netty-channel/</id>
    <published>2020-10-21T11:55:43.000Z</published>
    <updated>2021-08-26T12:23:36.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Channel"><a href="#什么是Channel" class="headerlink" title="什么是Channel"></a>什么是Channel</h3><p>Channel（当然是Netty自己抽象的Channel）是netty的网络操作对象，也可以这么说，Channel是与网络Socket套接字的联系。但是归根究底，Channel是一个用于I/O操作的组件，负责诸如：读，写，连接，绑定等操作。</p><h3 id="Channel能做写什么事情"><a href="#Channel能做写什么事情" class="headerlink" title="Channel能做写什么事情"></a>Channel能做写什么事情</h3><p>Channel为用户提供了：</p><ul><li>Channel的当前状态（例如，是否打开？是否已连接？）</li><li>Channel的ChannelConfig配置参数（例如，接收缓冲区的大小）</li><li>通道支持的I / O操作（例如，读，写，连接和绑定）</li><li>ChannelPipeline处理所有与该通道相关的I/O事件和请求</li></ul><h3 id="Channel的工作原理"><a href="#Channel的工作原理" class="headerlink" title="Channel的工作原理"></a>Channel的工作原理</h3><h3 id="Channel的功能介绍"><a href="#Channel的功能介绍" class="headerlink" title="Channel的功能介绍"></a>Channel的功能介绍</h3><p>我们接下来就来了解一下Channel大概涵盖了那些功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelId id();</span><br></pre></td></tr></table></figure><p>返回的是一个ChannelId对象，通过调用ChannelId相关的方法，获取到的是字符串类型的Id，这个Id代表了当前这个Channel通道，是Channel的唯一标识，可以理解为是一个key。他的可能生成策略如下：</p><ol><li>机器的MAC地址等可以代表全局唯一的信息；</li><li>当前的进程ID；</li><li>当前系统的毫秒/纳秒；</li><li>32位的随机整型数；</li><li>32位自增的序列数；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventLoop eventLoop();</span><br></pre></td></tr></table></figure><p>这个方法返回的是EventLoop.Channel需要注册到多路复用器上，用于处理I/O事件，通过此方法可以获取到当前Channel注册的EventLoop。EventLoop本质上就是处理网络读写的Reactor线程。在Netty中，它不单单只是用于处理网络事件，也可以用来执行定时任务和用户自定义的NioTask等任务。（具体可以阅读EventLoop的相关博客内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel parent();</span><br></pre></td></tr></table></figure><p>对于服务端的Channel来说，它的父Channel为null。对于客户端来说，它的parent就是创建它的ServerSocketChannel。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelConfig config();</span><br></pre></td></tr></table></figure><p>获取当前Channel的配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpen();</span><br></pre></td></tr></table></figure><p>用于判断当前Channel是否已经打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isRegistered();</span><br></pre></td></tr></table></figure><p>判断当前Channel是否已经注册到EventLoop上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isActive();</span><br></pre></td></tr></table></figure><p>判断当前channel是否处于激活状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress localAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel绑定的本地地址，若当前channel未绑定，则返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress remoteAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel连接的远端地址，若当前Channel没有被连接，则返回null。</p><p>以上是一些Channel的一些方法的定义，由于本身Channel是一个抽象的接口，所以Channel里面只有方法的定义而没有涉及到一些具体的操作，详情还是要结合源码来一起分析Channel的。</p><h3 id="Channel源码分析"><a href="#Channel源码分析" class="headerlink" title="Channel源码分析"></a>Channel源码分析</h3><p>由于Channel是一个顶层接口，其实现类非常的多，如果读者有兴趣想进一步了解的，可以从官网上下载其源码进行分析Channel到底有哪些实现类，以及这些实现类到底能做些什么事情。这里我们就主要分析其两个比较主要的实现类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="Channel继承关系类图"><a href="#Channel继承关系类图" class="headerlink" title="Channel继承关系类图"></a>Channel继承关系类图</h4><p>首先看 NioServerSocketChannel 的继承关系类图：</p><p><img src="/images/netty_channel_class_extends.png" alt="netty_channel_class_extends.png"></p><p>其次是 NioSocketChannel 的继承关系类图：</p><p><img src="/images/netty_nio_socket_channel.png" alt="netty_nio_socket_channel.png"></p><p>刨除Channel顶层接口实现的几个接口以及AbstractChannel抽象类继承的抽象类之外，NioServerSocketChannel 和 NioSocketChannel的继承关系还是相对简单的。</p><p>下面我们就来具体的分析。</p><h4 id="AbstractChannel的源码分析"><a href="#AbstractChannel的源码分析" class="headerlink" title="AbstractChannel的源码分析"></a>AbstractChannel的源码分析</h4><h5 id="成员变量的定义"><a href="#成员变量的定义" class="headerlink" title="成员变量的定义"></a>成员变量的定义</h5><p>先来看一下AbstractChannel成员变量的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final Channel parent;&#x2F;&#x2F; 父Channel</span><br><span class="line">private final ChannelId id;&#x2F;&#x2F; Channel全局唯一的ID</span><br><span class="line">private final Unsafe unsafe;&#x2F;&#x2F; Unsafe实例</span><br><span class="line">private final DefaultChannelPipeline pipeline;&#x2F;&#x2F; 当前Channel对应的PipeLine</span><br><span class="line">private volatile SocketAddress localAddress;</span><br><span class="line">private volatile SocketAddress remoteAddress;</span><br><span class="line">private volatile EventLoop eventLoop;</span><br><span class="line">private volatile boolean registered;</span><br><span class="line">private boolean closeInitiated;</span><br><span class="line">private Throwable initialCloseCause;</span><br><span class="line">private boolean strValActive;</span><br><span class="line">private String strVal;</span><br></pre></td></tr></table></figure><p>结合前面Channel的功能介绍，不难发现，这里面定义的一些个成员变量基本都是围绕着Channel的功能展开的，聚合了所有Channel使用到的能力对象，由AbstractChannel提供初始化和统一的封装，对于一些与子类强相关的方法则一抽象的形式去定义，由子类自己去具体实现。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractChannel(Channel parent) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       id &#x3D; newId();</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">protected AbstractChannel(Channel parent, ChannelId id) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="核心API的分析"><a href="#核心API的分析" class="headerlink" title="核心API的分析"></a>核心API的分析</h5><p>在Channel进行I/O操作的时候，他会触发对应的事件方法。Netty基于事件驱动，所以也就是说当Channel进行I/O操作的时候会产生响应的I/O事件，然后事件在PipeLine里面传播，然后由对应的ChannelHandler对事件进行拦截处理，有点类似于AOP。<br>大体看一下AbstractChannel的基本I/O操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture close(ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.close(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Channel read() &#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture write(Object msg) &#123;</span><br><span class="line">    return pipeline.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面图不难看出AbstractChannel的一些I/O操作也都是调用了DefaultChannelPipeline的方法来进行I/O的操作的，那也就是可以这么理解，AbstractChannel最最主要的作用就是对Channel一些功能点的初始化，其中最重要的是对DefaultChannelPipeline的初始化操作，因为AbstractChannel后续的I/O操作也都是调用它的方法来实现的，至此，AbstractChannel的源码我们也基本有了一定的了解。</p><p>下面我们再来看看在类图中AbstractChannel的下一级子类的源码。</p><h4 id="AbstractNioChannel源码分析"><a href="#AbstractNioChannel源码分析" class="headerlink" title="AbstractNioChannel源码分析"></a>AbstractNioChannel源码分析</h4><h5 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h5><p>老规矩，先从成员变量来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line">&#x2F;&#x2F; 代表JDK SelectionKey的OP_READ</span><br><span class="line">protected final int readInterestOp;</span><br><span class="line">volatile SelectionKey selectionKey;- </span><br><span class="line">boolean readPending;</span><br><span class="line">&#x2F;&#x2F; 连接操作结果</span><br><span class="line">private ChannelPromise connectPromise;</span><br><span class="line">&#x2F;&#x2F; 连接超时定时器</span><br><span class="line">private ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br><span class="line">&#x2F;&#x2F; 请求通讯地址</span><br><span class="line">private SocketAddress requestedRemoteAddress;</span><br></pre></td></tr></table></figure><p>第一个参数：这里定义了一个SelectableChannel，由于NIO Channel，NioSocketChannel和NioServerSocketChannel需要共用，所以定义了一个JDK NIO的SocketChannel和ServerSocketChannel的公共父类SelectableChannel用于设置SelectableChannel参数和进行I/O操作。</p><p>第二个参数：readInterestOp，如注解所示，这代表了JDK SelectionKey的OP_READ。</p><p>第三个参数：一个由Volatile修饰的selectionKey，这个key是Channel注册到EventLoop（Selector）之后返回的一个代表了这个Channel的key，通过这个key可以获取到对应的Channel，也代表了当前的Channel是处于什么操作：</p><ul><li>OP_ACCEPT：有新的网络连接可以 accept，值为 16</li><li>OP_CONNECT：代表连接已经建立，值为 8</li><li>OP_READ：代表读操作，值为 1</li><li>OP_WRITE：代表写操作，值为 4</li></ul><p>由于Channel会面临多个业务线程并发的写操作，所以使用volatile来让其他线程及时感知到当前Channel的状态。</p><h5 id="核心API源码分析"><a href="#核心API源码分析" class="headerlink" title="核心API源码分析"></a>核心API源码分析</h5><p>首先是同于Channel注册的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doRegister() throws Exception &#123;</span><br><span class="line">        boolean selected &#x3D; false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">                 if (!selected) &#123;</span><br><span class="line">    eventLoop().selectNow();</span><br><span class="line">                    selected &#x3D; true;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br></pre></td></tr></table></figure><p>其中方法javaChannel（）返回的其实就是在它成员变量里面定义了的SelectableChannel。SelectableChannel是JDK的NIO自带的通道视图。<br>看到这其实可以看出，底层的Netty其实还是调用了JDk的NIO来实现的。在register方法中的eventLoop（）方法返回的是其父类的成员变量定义的eventLoop，是一个NioEventLoop，然后获取其成员变量中定义的Selector多路复用器。在传入register注册方法里面的ops是0，则说明这里的注册对仍和I/O操作事件都不感兴趣，这里只是简单的将当前的Channel注册进Selector中。如果注册成功，则返回selectionKey，通过selectionKey可以从Selector中获取Channel对象。（SelectionKey是绑定Selector和Channel的中间纽带，之间是一对一的关系）<br>如果当前注册返回的selectionKey已经被取消，则抛出CancelledKeyException异常，捕获该异常进行处理。如果第一次处理该异常，调用多路复用器的selectNow（）方法将已经取消的selectionKey从多路复用器中删除。操作成功之后，将selected置为true，说明之前失效的selectionkey已经被删除。 继续发起下一轮注册操作，如果成功则退出，如果仍然发生CancelledKeyException异常，说明我们无法删除已经被取消的selectionkey，按理由这种操作不该发生，所以直接抛出异常到上层，由其自行处理。</p><p>接下来是另一个方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doBeginRead() throws Exception &#123;</span><br><span class="line">       final SelectionKey selectionKey &#x3D; this.selectionKey;</span><br><span class="line">       if (!selectionKey.isValid()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       readPending &#x3D; true;</span><br><span class="line">       final int interestOps &#x3D; selectionKey.interestOps();</span><br><span class="line">       if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在准备读取数据的时候需要先设置网络操作位为读，设置完之后才可以监听读事件。</p><p>至此AbstractNioChannel的源码基本就阅读完毕了，根据上面的分析，基本可以这么理解，AbstractNioChannel的作用是将当前的Channel通过NioEventLoop绑定到Selector多路复用器上面，这里是一个注册的作用。</p><p>下面我们继续往下看类图的下一部分AbstractNioByteChannel：</p><h4 id="AbstractNioByteChannel源码分析"><a href="#AbstractNioByteChannel源码分析" class="headerlink" title="AbstractNioByteChannel源码分析"></a>AbstractNioByteChannel源码分析</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable flushTask &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; Calling flush0 directly to ensure we not try to flush messages that were added via write(...) in the</span><br><span class="line">            &#x2F;&#x2F; meantime.</span><br><span class="line">            ((AbstractNioUnsafe) unsafe()).flush0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>AbstractNioByteChannel的成员变量就是一个Runnable类型的flushTask，负责继续写半包消息。</p><h5 id="API源码分析"><a href="#API源码分析" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这一块比较主要的方法是doWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">       do &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               clearOpWrite();</span><br><span class="line">               &#x2F;&#x2F; Directly return here so incompleteWrite(...) is not called.</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           writeSpinCount -&#x3D; doWriteInternal(in, msg);</span><br><span class="line">       &#125; while (writeSpinCount &gt; 0);&#x2F;&#x2F; 发送的消息不为空则继续doWriteInternal</span><br><span class="line">       incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上至下，首先通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount();</span><br></pre></td></tr></table></figure><p>获取此次写总共需要执行的循环次数。【循环次数是指一次发送没有完成（写半包），继续循环发送的次数】<br>然后从传递的参数ChannelOutboundBuffer调用current（）方法弹出一条消息，判断消息是否是null，如果是null，则说明消息发送数组里面所有等待发送的消息都发送完毕，清除写半包标记，结束循环。来看一下是如何清除写半包标识的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final void clearOpWrite() &#123;</span><br><span class="line">        final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final int interestOps &#x3D; key.interestOps();</span><br><span class="line">        if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">            key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从当前Selectionkey中获取网络操作位，然后与selectionkey.OP_WRITE做按位与，如果不等于0，说明当前的selectionkey是iswritable的，需要清除写操作位。 清除方法很简单，就是selectionkey.op_write取非之后与愿操作位按位与操作，清除selectionkey的写操作位。</p><p>再来看一下这边的循环次数是如何获取的，先看doWriteInternal代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      if (msg instanceof ByteBuf) &#123;</span><br><span class="line">          ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">          if (!buf.isReadable()) &#123;</span><br><span class="line">              in.remove();</span><br><span class="line">              return 0;</span><br><span class="line">          &#125;</span><br><span class="line">          final int localFlushedAmount &#x3D; doWriteBytes(buf);</span><br><span class="line">          if (localFlushedAmount &gt; 0) &#123;</span><br><span class="line">in.progress(localFlushedAmount);</span><br><span class="line">if (!buf.isReadable()) &#123;</span><br><span class="line">                  in.remove();</span><br><span class="line">              &#125;</span><br><span class="line">              return 1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里是有两部分的，一部分是对普通ByteBuf的逻辑，还有一部分是对FileRegion的判断，这里主要是ByteBuf。<br>首先，判断的当然是当前消息的类型是否是ByteBuf类型，如果是，则进行强转，然后判断当前的小时是否是可读的，若消息不可读，则直接从发送环形数组中删除当前消息，继续循环其他的消息。<br>然后继续向下走，判断消息可读，然后将当前buf的数据写入底层Chnannel，返回的是发送总数，所以这里的localFlushedAmount是指本次发送的字节数。我们来看看这个doWriteBytes底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected int doWriteBytes(ByteBuf buf) throws Exception &#123;</span><br><span class="line">        final int expectedWrittenBytes &#x3D; buf.readableBytes();</span><br><span class="line">        return buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难发现，其实际是将buf中可读的字节都写出到了目标Channel中。<br>回到doWriteInternal方法，我们就不用疑惑是否会出现localFlushedAmount大于0（也代表了写出了数据），然后buf还是可读的这种情况的出现了。在写出完毕之后，会调用ChannelOutboundBuffer更新发送进度信息。然后接着判断当前消息是否可读，不可读便从当前环形数组将当前消息删除。</p><p>至此，我们的doWrite方法已经快接近尾声了，循环部分已经分析完毕了，我么接着来看最后一个方法–incompleteWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line"></span><br><span class="line">protected final void incompleteWrite(boolean setOpWrite) &#123;</span><br><span class="line">       if (setOpWrite) &#123;         </span><br><span class="line">           setOpWrite();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">    clearOpWrite();</span><br><span class="line">           eventLoop().execute(flushTask);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里在调用incompleteWrite方法时候传入了循环次数来与0进行比较，如果循环次数不是小于0的，说明之前还有消息没有写完，因为循环没有结束嘛，所以当前如果消息没有写完，则调用setOpWrite（）方法去重新为当前Channel的SelectionKey设置写操作位。（注意⚠️：当SelectionKey的OP_WRITE的操作位被设置，那么当前Channel对应的Selector多路复用器就会不断的轮询对应的Channel用于处理没有处理完的半包消息，直到写操作位被清除为止。）<br>如果没有设置写操作位，那么就需要启用一个单独的Runnable，将其加入到EventLoop之中，由Runnable来负责处理写半包消息，他的实现也很简单，就是调用了flush（）来发送缓冲区的消息。</p><p>好了，AbstractBioByteChannel的源码到此就分析的差不多了。</p><p>下面就接着来分析NioServerSocketChannel的父类 – AbstractNioMessageChannel</p><h4 id="AbstractNioMessageChannel的源码分析"><a href="#AbstractNioMessageChannel的源码分析" class="headerlink" title="AbstractNioMessageChannel的源码分析"></a>AbstractNioMessageChannel的源码分析</h4><p>由于这个类没有成员变量，我们就直接跳到API源码分析。</p><h5 id="API源码分析-1"><a href="#API源码分析-1" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这里主要实现方法是doWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">       final int interestOps &#x3D; key.interestOps();</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">                   key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               boolean done &#x3D; false;</span><br><span class="line">               for (int i &#x3D; config().getWriteSpinCount() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                   if (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                       done &#x3D; true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (done) &#123;</span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F; Did not write all messages.</span><br><span class="line">                   if ((interestOps &amp; SelectionKey.OP_WRITE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                       key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (continueOnWriteError()) &#123;</span><br><span class="line">                   in.remove(e);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   throw e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>嗯姆。。。不对，等等！！！这代码好像在哪见过！没错，这里的代码和前面分析的AbstractNioByteChannel的doWrite方法几乎一模一样，AbstractNioByteChannel的doWrite多了一些封装，而这里写的比较直白一些。</p><p>如果仔细看，并且你还记得之前的AbstractNioByteChannel的大概的实现方式，你会发现，这里的doWriteMessage发送的是一个直接的pojo，而AbstractNioByteChannel发送的是ByteBuf或者FileRegion，还有就是，这里的处理半包的方式只采用了Selector多路复用器对对应的带有写操作位的Channel的轮询操作来处理未发送完的半包消息的。</p><p>接下来我们将会分析在类图最下面的两个类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="NioServerSocketChannel源码分析"><a href="#NioServerSocketChannel源码分析" class="headerlink" title="NioServerSocketChannel源码分析"></a>NioServerSocketChannel源码分析</h4><p>这部分的源码比较简单，先来看一下它的成员变量和静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final ChannelMetadata METADATA &#x3D; new ChannelMetadata(false, 16);</span><br><span class="line">private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER &#x3D; SelectorProvider.provider();</span><br><span class="line">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">   return provider.openServerSocketChannel();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          throw new ChannelException(</span><br><span class="line">                  &quot;Failed to open a server socket.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> private final ServerSocketChannelConfig config;</span><br></pre></td></tr></table></figure><p>首先是定义了一个ChannelMetadata用于存储元信息，然后是定义了一个SelectorProvider，然后用这个provider来打开通道。<br>最后是一个ServerSocketChannelConfig用来配置TCP参数。</p><p>来看一下NioServerSocketChannel的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannel() &#123;</span><br><span class="line">    this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(SelectorProvider provider) &#123;</span><br><span class="line">    this(newSocket(provider));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config &#x3D; new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仅有的三个构造函数之中，除了最后一个由调用者传递的ServerSocketChannel之外，其余两个构造函数都会在初始化的时候调用前面定义好的newSocket方法来生成一个ServerSocketChannel，而这个ServerSocketChannel是JDK NIO的Channel，然后调用到最后一个重载构造函数实现。最后你会发现，这里参数的传递到了AbstractNioChannel的构造函数中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.ch &#x3D; ch;</span><br><span class="line">        this.readInterestOp &#x3D; readInterestOp;</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.configureBlocking(false);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; catch (IOException e2) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Failed to close a partially initialized socket.&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 Channel 的 doReadMessages ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</span><br><span class="line">    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());</span><br><span class="line">    try &#123;</span><br><span class="line">        if (ch !&#x3D; null) &#123;</span><br><span class="line">            buf.add(new NioSocketChannel(this, ch));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t);</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (Throwable t2) &#123;</span><br><span class="line">            logger.warn(&quot;Failed to close a socket.&quot;, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过Netty的SocketUtils工具类接受客户端的连接，看一下传入的JavaChannel（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected ServerSocketChannel javaChannel() &#123;</span><br><span class="line">        return (ServerSocketChannel) super.javaChannel();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>往下走，会来到AbstractNioChannel ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line"></span><br><span class="line">protected SelectableChannel javaChannel() &#123;</span><br><span class="line">        return ch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不多分析这里的SelectableChannel，接着分析doReadMessages。<br>在接受了新的客户端连接之后，首先判断创建的连接是否是空，若不是空连接，则利用当前的NioServerSocketChannel和SocketChannel来创建一个新的NioSocketChannel，并将其加入List<Object> buf中，返回1，代表读取连接数据成功。<br>对于NioServerSocketChannel的读取操作就是接受客户端的连接，创建NioSocketChannel。</p><p>对于一些NioServerSocketChannel无需调用的方法，作者直接是返回了UnsupportedOperationException的异常来提示。</p><p>至此NioServerSocketChannel就分析完毕了，记住最重要的一点，NioServerSocketChannel的最要作用就是接受连接，创建NioSocketChannel。</p><p>接下来，我们来分析一下NioSocketChannel的实现。</p><h4 id="NioSocketChannel源码分析"><a href="#NioSocketChannel源码分析" class="headerlink" title="NioSocketChannel源码分析"></a>NioSocketChannel源码分析</h4><h5 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h5><p>重点分析与客户端连接有关的方法，首先来看连接 doConnect()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">        if (localAddress !&#x3D; null) &#123;</span><br><span class="line">            doBind0(localAddress);</span><br><span class="line">        &#125;</span><br><span class="line">         boolean success &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">    boolean connected &#x3D; </span><br><span class="line">                     SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">            if (!connected) &#123;</span><br><span class="line"> selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">            &#125;</span><br><span class="line">            success &#x3D; true;</span><br><span class="line">            return connected;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                doClose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断本地socket地址是否存在，若不为空，则调用doBind0方法去绑定本地Socket地址。<br>然后发起TCP连接远端Socket地址，若连接成功，则返回true，连接失败，则直接抛出I/O异常，若暂时没有连接上，不知道具体状态，则返回false。<br>若没有连接成功（不是失败），则重置Channel的SelectionKey的操作位为连接操作位。若是在连接的时候抛出了I/O异常，则success参数就为false，调用doClose（）关闭连接。</p><h5 id="写半包"><a href="#写半包" class="headerlink" title="写半包"></a>写半包</h5><p>先看一下源码的写半包的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">        SocketChannel ch &#x3D; javaChannel();</span><br><span class="line">        int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">        do &#123;</span><br><span class="line">            if (in.isEmpty()) &#123;</span><br><span class="line">                clearOpWrite();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">            ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br><span class="line">            int nioBufferCnt &#x3D; in.nioBufferCount();</span><br><span class="line"></span><br><span class="line">            switch (nioBufferCnt) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    writeSpinCount -&#x3D; doWrite0(in);</span><br><span class="line">                    break;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    ByteBuffer buffer &#x3D; nioBuffers[0];</span><br><span class="line">                    int attemptedBytes &#x3D; buffer.remaining();</span><br><span class="line">                    final int localWrittenBytes &#x3D; ch.write(buffer);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    long attemptedBytes &#x3D; in.nioBufferSize();</span><br><span class="line">                    final long localWrittenBytes &#x3D; ch.write(nioBuffers, 0, nioBufferCnt);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite((int) attemptedBytes, (int) localWrittenBytes,</span><br><span class="line">                            maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (writeSpinCount &gt; 0);</span><br><span class="line">        incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实在太多了，这一部分的处理也是比较复杂的，但是别急，都是写方法，如果你对于之前的源码分析都掌握了的话，其实这部分的源码也是换汤不换药的。<br>定义的SocketChannel基本都是从一个统一的方法javaChannel（）里面获取的。<br>既然要读，那首先我们就得知道这个数据我们得读多少次能读完，代码的体现就是通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount()</span><br></pre></td></tr></table></figure><p>来获取循环次数。这个是定义在ChannelConfig里面的，默认循环次数是16，取决于JVM运行的平台。<br>来到循环体里面，如果buf是空的，则清除写操作位，并return；<br>若不是空的，则继续向下走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br></pre></td></tr></table></figure><p>获取设置的单个ByteBuf的最大字节数，也就是设定了每个ByteBuf允许存储的最大字节的数量，获得了ByteBuf的最大字节数之后紧接着就是获取ByteBuf数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br></pre></td></tr></table></figure><p>通过ChannelOutboundBuffer获取ByteBuf数组，其中传递的参数是设置好的单个ByteBuf的最大字节数，以及允许的最大缓冲区数量，然后返回ByteBuf数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nioBufferCnt &#x3D; in.nioBufferCount();</span><br></pre></td></tr></table></figure><p>调用了buf的nioBufferCount（）方法，来获取需要发送的ByteBuffer数组个数。nioBufferCount（）方法必须在调用了nioBuffers（）之后才可以调用。</p><p>进入条件语句之后，若需要发送的ByteBuffer为0，则说明无消息需要发送，但是可能会有别的事情需要处理，所以调用了doWrite0，并将自旋减去其返回的数值。<br>当需要发送的ByteBuffer个数为1，则直接取数组内的第一个ByteBuffer去发送，然后是获取缓冲区剩余的可写字节数赋值给attemptedBytes。在调用了SocketChannel的write（）方法之后，方法会返回写入SocketChannel的字节数，判断写入的字节数，小于等于0说明TCP缓冲区已经满了，很肯能无法在继续写入，因此从循环中挑出，同时调用incompleteWrite（true）将写半包标识设置为true，用于向多路复用器注册写操作位，告诉多路复用器有没有发送完的半包消息，需要轮训出就绪的SocketChannel继续发送。<br>在处理完这些事情之后，ChannelOutbountBuffer的该部分缓冲区已经使用完毕了，于是会调用ChannelOutboundBuffer的清除方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in.removeBytes(localWrittenBytes);</span><br></pre></td></tr></table></figure><p>参数是之前写入SocketChannel的字节数。来看一下他的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void removeBytes(long writtenBytes) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        Object msg &#x3D; current();</span><br><span class="line">        if (!(msg instanceof ByteBuf)) &#123;</span><br><span class="line">            assert writtenBytes &#x3D;&#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        final ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        final int readerIndex &#x3D; buf.readerIndex();</span><br><span class="line">        final int readableBytes &#x3D; buf.writerIndex() - readerIndex;</span><br><span class="line">        if (readableBytes &lt;&#x3D; writtenBytes) &#123;</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                progress(readableBytes);</span><br><span class="line">                writtenBytes -&#x3D; readableBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            remove();</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; readableBytes &gt; writtenBytes</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                buf.readerIndex(readerIndex + (int) writtenBytes);</span><br><span class="line">                progress(writtenBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       clearNioBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，首先是从当前ChannelOutBoundBuffer弹出第一条发送的ByteBuf，然后获取读索引和可读字节数（可读字节数 = 写索引 - 读索引），<br>将可读字节数与已经发送的字节数进行比较，可读字节数小于等于已发送字节数说明当前的bytebuf已经完全被发送出去了，那么就更新ChannelOutboundBuffer的发送进度信息以及将写指针前移，然后清空该部分内存空间。若可读字节数大于已写出字节数，说明出现了半包问题，那就需要更新可读索引，将将读索引后移writtenBytes个位置，这样当下次轮询到的时候就会重新从正确的读索引处重新开始读取消息，然后也是更新ChannelOutboundBuffer的发送进度信息。</p><p>好了，Channel的部分源码解读到这就差不多了，由于篇幅限制，Channel的Unsafe就不再这里继续展开了，笔者会另开一章来专门介绍Unsafe的源码，敬请期待吧。</p><p>谢谢阅读。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Channel&quot;&gt;&lt;a href=&quot;#什么是Channel&quot; class=&quot;headerlink&quot; title=&quot;什么是Channel&quot;&gt;&lt;/a&gt;什么是Channel&lt;/h3&gt;&lt;p&gt;Channel（当然是Netty自己抽象的Channel）是netty的网络</summary>
      
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
  </entry>
  
</feed>
