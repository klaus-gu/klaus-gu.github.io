<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进学致和，行方思远。</title>
  
  <subtitle>人不过是一尾芦草,是自然界最脆弱的东西,但人却是一尾能思考的芦草。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-03T13:49:47.557Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>klaus_turbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手写Spring核心 -- 如何实现一个最简单的spring容器</title>
    <link href="http://example.com/2022/09/03/spring-01/"/>
    <id>http://example.com/2022/09/03/spring-01/</id>
    <published>2022-09-03T13:30:43.000Z</published>
    <updated>2022-09-03T13:49:47.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手写Spring核心-–-如何实现一个最简单的spring容器"><a href="#手写Spring核心-–-如何实现一个最简单的spring容器" class="headerlink" title="手写Spring核心 – 如何实现一个最简单的spring容器"></a>手写Spring核心 – 如何实现一个最简单的spring容器</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工作了这么久，每当做的工作内容是和应用开发相关的，就抛不开 spring 这个话题。甚至在一些面试中，面试官还是不停的在问：“spring 是什么？怎么解决循环依赖？”巴拉巴拉的一大堆和spring相关的问题。当然背过八股文，看过面经的对这种问题回答起来都是溜到飞起，但如果换一个面经没有的，八股文没有的，你是不是还能回答的出来？或者说在实际的应用场景中，你对spring真正的理解，决定了你在开发或者解决问题的时候站在什么样子的角度去思考解决这个事情。于是在某一个深夜，我决定去一探 spring 的庐山真面目，然后手写一个 spring。为什么要这么做呢？其实作为一个实打实的理科生，深知对于所有的技术，靠死记硬背是不行的，必须以理科思维理解为目的的学会。剔除 Spring 源码中繁杂的部分，以 IOC 为主体去逐步的实现 Spring 中比较核心的内容。</p><p>废话不多说，我们直接进入正题。</p><h3 id="Spring-bean容器是什么？"><a href="#Spring-bean容器是什么？" class="headerlink" title="Spring bean容器是什么？"></a>Spring bean容器是什么？</h3><p>要回答这个问题，我们首先要知道，Spring容器实际真正做的是什么事情。在spring容器中，它包含并管理着应用对象的配置和生命周期，在这个意义上，spring其实是一种用于承载对象的容器，我们可以配置每一个Bean对象是如何创建，这些bean可以创建成一个单独的实例或者每次需要的时候都生成一个新的实例，以及他们是如何相互关联构建和使用的。</p><p>如果一个bean对象交给spring容器管理，那么这个bean对象就应该以零件的方式被拆解后存放到bean的定义中，这就相当于是一种把bean对象解耦的操作，可以由spring更加容易的管理，这样的将实际bean对象以某种方式拆解后保存的方式也是前面我们提到的循环依赖能够得到解决的根本之一。</p><p>当一个bean对象被定义存放之后，再由spring统一进行装配，这个过程包括bean的初始化，属性填充等，在种种的操作结束之后，我们就可以通过我们熟悉的getBean等api去完整的使用一个bean实例化之后的对象了。</p><p>说了这么多，所以你能总结出这个问题的答案了吗？</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>我们一直在说spring容器，spring容器，spring容器。那必然就是说这个spring是可以存放我们的bean对象，所以才会称之为容器的。所以，我认为所有可以存放数据的具体的数据结构的实现，都可以成为容器，例如：ArrayList，HashSet等，在我们spring bean容器的场景下，使用HashMap来作为我们最底层的容器实现最合适不过了。</p><p>从以往使用的经历来说，完成一个基础的spring bean容器的实现，需要bean的定义，注册，获取这么三个基本的步骤：</p><ul><li>定义：BeanDefinition，可能你在看spring源码的时候这是出现的最多的一个类，它会包括诸如singleton，prototype，BeanClassName等，但现在我们不会将它定义的太复杂。</li><li>注册：这个过程就相当于我们把数据放入到hashmap的过程，只不过现在hashmap存放的是定义了bean的对象信息。</li><li>获取：一切的一切都是为了使用这个bean，所以最后一步就是获取对象，其中key是beanName，当spring容器初始化完毕之后，就可以通过api去获取了。</li></ul><p>首先我们先定义一个最简单的容器实现，用来展示上面的这三个步骤，类图如下：</p><p><img src="/images/spring01_%E5%85%B3%E7%B3%BB%E7%B1%BB%E5%9B%BE.png" alt="spring01_关系类图.png"></p><p>Spring Bean容器的整个实现内容非常简单，也仅仅是包括了一个简单的BeanFactory和BeanDefinition，这里的类名与spring源码保持一致，只不过现在的实现非常的简单。</p><h4 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition&#123;</span><br><span class="line"></span><br><span class="line">    private Object bean;</span><br><span class="line">    </span><br><span class="line">    public BeanDefinition(Object bean)&#123;</span><br><span class="line">        this.bean &#x3D; bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object getBean()&#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的bean定义中们只有一个Object用于存放Bean对象，在后面我们会逐步完善。</p><h4 id="Bean工厂"><a href="#Bean工厂" class="headerlink" title="Bean工厂"></a>Bean工厂</h4><p>看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BeanFactory&#123;</span><br><span class="line">    </span><br><span class="line">    private Map&lt;String,BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public Object getBean(String name)&#123;</span><br><span class="line">        return beanDefinitionMap.get(name).getBean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void registerBeanDefinition(String name,BeanDefinition beanDefinition)&#123;</span><br><span class="line">        beanDefinitionMao.put(name,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在bean工厂的实现中，包括了注册和获取bean，这里注册的是bean的定义信息。</p><p>好了，这就是最简单的spring容器的实现。可能有人要说了，你这不是忽悠人么？虽然我们这里实现的非常简单，但这种极其简单的实现内容就是整个spring容器中关于bean使用的最终效果，也是其基本最核心的原理。当然，这样的实现是不适用于生产的，后续会慢慢的扩充。</p><p>我们来写点测试的代码，看看我们的容器是否能完成我们所需要的功能。</p><p>先定义一个我们需要的bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserService&#123;</span><br><span class="line">    </span><br><span class="line">    public void queryUserInfo()&#123;</span><br><span class="line">        System.out.println(&quot;查询用户信息&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">        &#x2F;&#x2F; 1.初始化 BeanFactory</span><br><span class="line">        BeanFactory beanFactory &#x3D; new BeanFactory();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.注入bean</span><br><span class="line">        BeanDefinition beanDefinition &#x3D; new BeanDefinition(new UserService());</span><br><span class="line">        beanFactory.registerBeanDefinition(&quot;userService&quot;, beanDefinition);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.获取bean</span><br><span class="line">        UserService userService &#x3D; (UserService) beanFactory.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.queryUserInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看一下运行结果：</p><p><img src="/images/spring01_%E8%B0%83%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="spring01_调试结果.png"></p><p>ok，已经实现了我们所需要的功能，通过初始化容器，构造BeanDefinition，注册Bean的BeanDefinition，我们最终便可以通过容器来获取我们的Bean并使用它。</p><p>当然，这边实现的BeanFactory是我们的一个雏形，相对于这部分内容不足以难倒任何人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手写Spring核心-–-如何实现一个最简单的spring容器&quot;&gt;&lt;a href=&quot;#手写Spring核心-–-如何实现一个最简单的spring容器&quot; class=&quot;headerlink&quot; title=&quot;手写Spring核心 – 如何实现一个最简单的spring容</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 JVM 内存模型</title>
    <link href="http://example.com/2022/08/31/JVM/"/>
    <id>http://example.com/2022/08/31/JVM/</id>
    <published>2022-08-31T14:35:48.000Z</published>
    <updated>2022-09-01T05:48:13.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个Java工作者，我们每天都在码代码，运行代码，和Java不停的打交道。你有没有好奇过你写的这段代码是怎么运行的？他在机器上又是如何排布的？对于每个开发来说，了解其原理有助于我们更好的去理解我们写下的每一行代码，让我们更好的去优化我们的代码，理解问题，解决问题，甚至于当我们说出某一个术语的时候不至于因为不了解而被同行鄙视（胡说八道）。</p><p>相信科班出身的你不会忘记这四个字母：WORA，即：Write Once ，Run Anywhere，一次编写，到处运行。这是当时 Sun 推荐 Java 时候的噱头，用于展示 Java 的跨平台的语言特性。而这所谓的 WORA 所依托的正是一个叫做JVM的虚拟机，通过Java的虚拟机，Java 语言成功的实现了平台不相关性。我比较喜欢解耦，所以也可以说实现了开发语言与硬件平台的解耦，因为只要安装了 JVM 的虚拟机，就可以在毫无修改的情况下运行已编译好的 Java 代码。</p><p>说了这么多，可以意识到 JVM 对于 Java 的重要性有多么大。其中内容非常多，诸如类加载机制，JVM 运行时数据区域，GC 算法，JVM 内存模型等等，在这里我们就简单的看看 JVM 内存模型是什么样子的。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>总的来说，JVM 的内存模型总共划分了两大块区域：非堆区和堆区。非堆区，JVM 用永久代（PermanetGeneration）来存放方法区，（<br>在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念）。<br>一块是堆区。堆区分为两大块，一个是 Old 区（老年代），一个是 Young 区（新生代）。<br>Young区分为两大块，一个是 Survivor（S0+S1），一块是 Eden 区。 Eden:S0:S1=8:1:1 S0 和S1一样大，也可以叫 From 和 To。整个JVM内存模型很符合Ungar的分代垃圾回收，具体的不展开，<br>总体样子如下：</p><p><img src="/images/jvm1.png" alt="jvm1.png"></p><p>我们知道，一般对象和数组的创建会在堆中分配内存空间，关键问题是，堆中有这么多的区域，哪一个对象的创建到底是在哪个区域呢？</p><p>一般情况下，新创建的对象都会被分配到 Eden 区，一些特殊的大的对象会直接分配到 Old 区。<br>比如有对象A，B，C等创建在 Eden 区，但是 Eden 区的内存空间肯定有限，比如有100M，假如已经使用了100M或者达到一个设定的临界值，<br>这时候就需要对 Eden 内存空间进行清理，即垃圾收集，这样的 GC 我们称之为 Minor GC，Minor GC 指得是 Young 区的 GC，<br>有的也会称之为是 YGC。经过 GC 之后，有些对象就会被清理掉，有些对象可能还存活着，对于存活着的对象需要将其复制到 Survivor 区，<br>然后再清空 Eden 区中的这些对象。</p><h3 id="Survivor-区详解"><a href="#Survivor-区详解" class="headerlink" title="Survivor 区详解"></a>Survivor 区详解</h3><p>从上面的图我们可以看到，Survivor 区分为两块 S0 和 S1，也可以叫做 From 和 To。<br>在同一个时间点上，S0 和 S1 只能有一个区有数据，另外一个是空的。接着上面的 GC 来说，比如一开始只有 Eden 区和 From 中有对象，<br>To 中是空的。此时进行一次 GC 操作，From 区中对象的年龄就会+1，我们知道 Eden 区中所有存活的对象会被复制到 To 区，<br>From 区中还能存活的对象会有两个去处。若对象年龄达到之前设置好的年龄阈值，此时对象会被移动到 Old 区，<br>如果 Eden 区和 From 区 没有达到阈值的对象会被复制到To区。 此时 Eden 区和 From 区已经被清空(被 GC 的对象肯定没了，没有被 GC 的对象都有了各自的去处)。<br>这时候 From 和 To 交换角色，之前的 From 变成了 To，之前的 To 变成了 From。也就是说无论如何都要保证名为 To 的 Survivor 区域是空的。<br>Minor GC 会一直重复这样的过程，直到 To 区被填满，然后会将所有对象复制到老年代中。通常也叫 YGC。</p><h3 id="Old-区详解"><a href="#Old-区详解" class="headerlink" title="Old 区详解"></a>Old 区详解</h3><p>从上面的分析可以看出，一般 Old 区都是年龄比较大的对象，或者相对超过了某个阈值的对象。<br>在 Old 区也会有 GC 的操作，Old 区的 GC 我们称作为 Major GC ，也叫 FGC。</p><h3 id="Java-对象的生命周期"><a href="#Java-对象的生命周期" class="headerlink" title="Java 对象的生命周期"></a>Java 对象的生命周期</h3><p>一个普通的 Java 对象一开始的时候是在 Eden 区的，它可能会在 Eden 区域停留很长的时间。当 Eden 区在某一个时间点，对象实在是太多了，新生对象就会被迫前往 Survivor 区的 From 区。<br>当一个对象到达了 Survivor 区之后，它会在 From 和 To 区之间漂泊。直到该对象满足一定的条件，该对象就会被分配到 Old 区去（在分代垃圾回收中，对象在 GC 中存活了一定的次数之后上升到老年代中去，这个过程也叫做”晋升”）。<br>下图展现了一个对象的分配过程。</p><p><img src="/images/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="对象生命周期.png"></p><h3 id="为什么需要-Survivor-区-只有-Eden-不行吗？"><a href="#为什么需要-Survivor-区-只有-Eden-不行吗？" class="headerlink" title="为什么需要 Survivor 区?只有 Eden 不行吗？"></a>为什么需要 Survivor 区?只有 Eden 不行吗？</h3><p>先回答这么做的目的：减少 Full GC 。如果没有 Survivor,Eden 区每进行一次 Minor GC ,并且没有年龄限制的话， 存活的对象就会被送到老年代。<br>这样一来，老年代很快被填满,触发 Major GC (因为Major GC 一般伴随着 Minor GC,也可以看做触发了 Full GC )。<br>老年代的内存空间远大于新生代,进行一次 Full GC 消耗的时间比 Minor GC 长得多。<br>执行时间长有什么坏处?频发的 Full GC 消耗的时间很长,会影响大型程序的执行和响应速度（也许你听过 Stop the world，所有版本的虚拟机，升级的目的只有一个，那就是减少垃圾回收给程序带来的影响）。可能你会说，那就对老年代的空间进行增加或者较少咯。<br>假如增加老年代空间，更多存活对象才能填满老年代。虽然降低 Full GC 频率，但是随着老年代空间加大,一旦发生 FullGC ,执行所需要的时间更长。<br>假如减少老年代空间，虽然 Full GC 所需时间减少，但是老年代很快被存活对象填满,Full GC 频率增加。所以 Survivor 的存在意义,<br>就是减少被送到老年代的对象,进而减少 Full GC 的发生,Survivor 的预筛选保证,只有经历16次(默认第16次就去老年代) Minor GC 还能在新生代中存活的对象,<br>才会被送到老年代。</p><h3 id="为什么需要两个-Survivor-区？"><a href="#为什么需要两个-Survivor-区？" class="headerlink" title="为什么需要两个 Survivor 区？"></a>为什么需要两个 Survivor 区？</h3><p>最大的好处就是解决了碎片化。也就是说为什么一个 Survivor 区不行?第一部分中,我们知道了必须设置 Survivor 区。<br>假设现在只有一个 Survivor 区,我们来模拟一下流程:刚刚新建的对象在 Eden 中,一旦 Eden 满了,触发一次 Minor GC,<br>Eden 中的存活对象就会被移动到 Survivor 区。这样继续循环下去,下一次 Eden 满了的时候,问题来了,<br>此时进行 Minor GC,Eden 和 Survivor 各有一些存活对象,如果此时把 Eden 区的存活对象硬放到 Survivor 区,很明显这两部分对象所占有的内存是不连续的,<br>也就导致了内存碎片化。永远有一个 Survivor space 是空的,另一个非空的 Survivor space 无碎片。所以通过这哥步骤就很好的解决了碎片化严重的问题。</p><h3 id="新生代中-Eden-S1-S2-为什么是-8-1-1？"><a href="#新生代中-Eden-S1-S2-为什么是-8-1-1？" class="headerlink" title="新生代中 Eden:S1:S2 为什么是 8:1:1？"></a>新生代中 Eden:S1:S2 为什么是 8:1:1？</h3><p>GC 是统计学测算出当内存使用超过98%以上时，内存就应该被 minor gc 时回收一次。<br>但是实际应用中，我们不能较真的只给 他们留下2%，换句话说当内存使用达到98%时才GC 就有点晚了，应该是多一些预留10%内存空间，<br>这预留下来的空间我们称为S区（有两个s区  s1 和  s0），S区是用来存储新生代GC后存活下来的对象，大多数的对象都是朝生夕死，<br>生命周期短(大多是web应用，比如一个订单下好了，就好了)。而我们知道新生代GC算法使用的是复制回收算法。<br>所以我们实际GC发生是在，新生代内存使用达到90%时开始进行，复制存活的对象到S1区，要知道GC结束后在S1区活下来的对象，<br>需要放回给S0区，也就是对调(对调是指，两个S区位置互换,意味着再一次minor gc 时的区域 是eden 加上一次存活的对象放入的S区)，既然能对调，<br>其实就是两个区域一般大。这也是为什么会再有个10%的S0区域出来。这样比例就是8:1:1了 ，这里的eden区（80%） 和其中的一个  S区（10%）<br>合起来共占据90%，GC就是清理的他们，始终保持着其中一个  S  区是空留的，保证GC的时候复制存活的对象有个存储的地方。<br>所以，其实不一定非得是 8：1：1，就像 hashmap 的 0.75。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这些大概就是我对 JVM 内存模型的一些理解了，期间的垃圾回收非常的复杂，有兴趣的小伙伴可以去看看中村成洋的《垃圾回收的算法与实现》，这本书讲的是很不错的，一直从最开始的清除算法到后面的RC Immix算法<br>从简单到深入，我感觉写的还是不错的。一步步的从各方面解释算法，以及优化。还有就是比较基础的一些概念可以看周志明的《深入理解JAVA虚拟机》。</p><p>怎么说呢，个人认为对于虚拟机的理解是很重要的，只要是写java，必然就绕不开虚拟机，不理解就不能很好的去调优，就像医生一样，你不可能用一味药治好所有的病，作为java开发，你也不可能用那几句调优的命令去把你的程序优化到比较好的一个程度。</p><p>只能说，Java 很难。与大家共勉，有不对的希望大家指出，愿意与伙伴们一起更好的学习了解JVM。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个Java工作者，我们每天都在码代码，运行代码，和Java不停的打交道。你有没有好奇过你写的这段代码是怎么运行的？他在机器上又是如何排</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>技术选型时应该遵循的原则和应该避免的陷阱</title>
    <link href="http://example.com/2022/08/25/tech_select_learning/"/>
    <id>http://example.com/2022/08/25/tech_select_learning/</id>
    <published>2022-08-25T13:55:48.000Z</published>
    <updated>2022-08-25T07:47:27.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术选型时应该遵循的原则和应该避免的陷阱"><a href="#技术选型时应该遵循的原则和应该避免的陷阱" class="headerlink" title="技术选型时应该遵循的原则和应该避免的陷阱"></a>技术选型时应该遵循的原则和应该避免的陷阱</h1><p>我在创业之初时，对自己无法更快地做出技术栈相关决策非常不满。如今，我已经在 TeamViewer 工作了好几年，在给五百强公司做过几个项目后，学到了不少技巧，并愿意在此分享出来。</p><p>这篇文章引用了一个虚构角色 Erik，以采访的形式进行分享。</p><p>Stefan Miteski：Erik，让我们开门见山直切入主题吧。团队在构建 MVP 时，什么时候可以从“尽可能快”的理念转换为构建可延展性更强、更适于维护、可持续性更高的模式呢？<br>Erik：首先，不是所有的构想都需要代码来实现，用最便宜、最快的就行。我更倾向于选择能够最快完成任务的技术，哪怕这意味着我要用的某个低代码平台需要我在后续重写全部的代码，也都不是问题。所以这其实是一个基于团队技术背景的决定。如果团队中有人懂 NodeJS，那就选择 NodeJS，如果有人会 Python 那就用 Python。在这个阶段你不需要考虑最佳的质量过程、CI/CD，或者最佳敏捷方法。这些多余的累赘是初创公司在起始阶段不应思考的问题。在 MVP 阶段，你只需要做在黑客马拉松里会做的事。</p><p>简单来说，只有在拥有可能的收入资金后，可扩展性和流程才会变得重要。</p><p>Miteski：假设钱不是问题，那么在大公司中开发新项目这种情况呢？<br>Erik：这种情况也类似。在确保生存能力后再考虑可延展性。如果项目还在试水阶段，那就按照 MVP 的规划运行。如果项目已经稳定了，那这时候再考虑可延展性。</p><p>Miteski：确实，这么说就很明确。我常在指导初期创业者时，遇到很多的失败案例都是因为过早地在可延展性上消耗了太多的精力。由于构建的产品没人需要而导致的失败率（35%）要远高于错误的技术决策所导致的创业失败（8%）。<br>那么在扩容阶段呢？我们现在已经有了稳定的收入，终于可以抛弃初期乱糟糟的代码垃圾场了，这时我们应该选择什么技术呢？<br>Erik：根据康威定律，“设计系统的组织被限制生产设计，这些设计是这些组织的通信结构的副本。”所以在这个阶段，我们应考虑的是组织整体的结构设计，而不仅仅是技术栈或软件架构。组织需要的团队数量、团队间的合作模式是什么？如何保持团队间的统一性？测试的流程是什么？CI/CD、发现策略怎么制定？如何实现营销和开发工作的一致性？如何确保企业文化的健康发展？如何获取并整合人才？</p><p>所有的技术都是建立在问题解决的基础上，当然项目也是如此。然而，网页应用的后端该用 Java 还是 C# 开发？数据库该用 SQL 还是 MySQL？这类问题的答案可能就不是那么的明显了。最直接的答案是在“应急架构原则”和“最后责任时刻”规则的前提下，将决定权交给团队，并从功能性和非功能性两方面深入研究。</p><p>其中，非功能性要求有：</p><p>线上社区的规模。如果你选择了 C# 而不是什么新奇的编程语言，那么除了完善的文档之外，你还将拥有来自 Jon Skeet 等人的支持，他在 StackOverflow 上已经有超过一百万的声望点数。也就是说，你能在互联网上找到 C# 语言相关问题答案的几率要远高于其他小众语言。除此之外你还要考虑这种语言可用的库有多少，支持是否成熟等问题。</p><p>用工市场的规模。附近大学的学生学的都是什么语言？当然，你也可以针对需要的技术对员工进行培训，但这又要搭进去大量项目开发时间。再加上如果你想要使用的语言并不常用或者是过时很久了，那么你还需要更高的预算以支付更高的薪酬。</p><p>系统的寿命。人类的寿命大概 70 年左右，而且还需要 9 个月才能从胚胎发育成人。如果我们想让系统持久存活，也需要类似的方法。这应该是长期的技术策略，而不是取决于我们所做的第一个决策。</p><p>在上线之后再做出系统重大改动有时感觉像在飞行时修理飞机。因此，将对系统而言至关重要的决策推迟到“最后责任时刻”是很明智的。</p><p>Miteski：那么什么是“最后责任时刻”呢？<br>Erik：这个概念来源于精益开发。返工的代价要远高于延迟的成本。而敏捷开发提倡经验主义——在实践中学习。如果你过早地做出不可逆转的决定，那么要承担的风险也会加倍。因此，我们需要谨慎决策，将其中可以学习的部分挑出来，以在做出重大决策前降低风险。</p><p>Miteski：”延迟”听起来像是与精益初创的原则相悖？毕竟速度是我们的主要竞争优势。<br>Erik：延迟决定不代表原地不动地思考问题。我们要围绕这个决策对架构进行探索，了解业务情况、用户需求，这样才能在最后责任时刻做出最佳选择。我们还可以做个模拟系统，并围绕其构建各种 API。</p><p>Miteski：那么，业务情况又是怎么影响技术栈选择的决策呢？<br>Erik：可以有很多方面：</p><p>确定你的竞争优势，以及可以为这种优势提供最好支持的技术。</p><p>将与组织竞争优势无关的各种技术解决方案交由第三方处理，掌控并构建属于自己的技术栈，后者才是竞争优势的一部分。这种理念适用于所有技术及非必要服务。但要注意，不要让你的供应商发展成自己的竞争对手。当年微软和英特尔可都曾是 IBM 的供应商。</p><p>如果不是必须采用裸机的话，那么云供应商是个不错的选择。但该选哪个供应商呢？还是那句话，这要取决于业务的本质。如果你的客户非常在意云服务在事故期间的反应速度，那么就仔细研究它们的 SLA 以及可以建立的合作伙伴关系类型。如果不是，那就以它们能提供的服务为标准参考。从基础的 CloudWatch 到内容丰富的 Kubernetes 之类，哪一种可以持续加快你的部署速度？最后，不要忘了价格因素。选择云合作伙伴就像选择你初创公司的合伙人，不要着急，不要急于求成，这样也方便将来深度集成他们的服务。</p><p>Miteski：那么，随着组织的成熟发展，我们可能会面临什么陷阱吗？<br>Erik：首先是电车陷阱。这种陷阱通常会出现在不健康的组织环境中。我听说过的一个例子是，曾经有位工程师负责了某个科技巨头项目中绝大部分的主要功能，并借此要挟公司涨薪。在没有得到想要的结果后他离开了公司。最终公司迫于无人能维护而只能重做整个项目。</p><p>导致竖井的原因之一是管理层对快速交付的施压。因为在高压环境下，拥有特定技术背景的开发者会效率更高，所以在处理技术负债时，我们还需要将反竖井纳入考虑范围内。</p><p>但无论竖井为什么会出现，我们都需要意识到它们的存在是非常危险的。甚至很多大公司都会犯下把多位专业领域的工程师放在同一个篮子里的错误，万一这个篮子出了什么事，可能会影响到公司的存亡。如果这是你的公司正在做的事，那么是时候考虑换种方法做事了。将技术知识传播开，应用代理策略，让不在这个篮子里的其他工程师也开始做这部分的工作，只在“代理工程师”们被问题卡住时再咨询篮子里的专家。这种方法会短暂降低效率，但它确保了长期的鲁棒性，而且后续我们的工作效率会更高，你看是不是这个道理？</p><p>Miteski: 确实。<br>Erik：另一个要注意的是奶狗陷阱。有时候天真烂漫的想法会让我们沉浸其中无法自拔。就像是看着可爱的小奶狗，我们会因为它们当时可爱的外表和一瞬间的心动而决定收养它们，但却忽略了它们在未来十多年中的成长，并且在这期间需要不断地照料。在很多情况下，技术解决方案也会持续存在超过十年，我们在做技术决策时也需要将这点纳入考量范畴。我们不能为了某个工程师酒后天马行空的想法或产品经理在飞机上看杂志而脑洞大开的灵感，就把未来全部贡献进去。Visual FoxPro 在上世纪九十年代听起来像是个绝赞的新技术，但它并没有经受住时间的考验。类似的例子在科技坟地里并不少见，而随着现在前沿新科技发展的步伐，在未来这片坟地大概是不会寂寞了。</p><p>但反过来说，将所有新想法和实验性项目全部拒之门外也是很危险的。用微服务或低耦合系统，把系统中独立的一部分作为新技术的试验场，这种方法很适合实验性创新。如此一来，我们就可以在生产环境中实验新技术，而由于试验场并不与主要功能挂钩，且位置也不是很关键，后续如果需要关闭这部分功能也不会影响到客户使用。仍处于开发阶段的技术很危险，但我们可以用这个试验场来获得技术实操的经验，测试技术栈在现实场景中的表现并完善对它的认知。</p><p>Miteski：如果遵照“最后责任时刻”规则，并让组织中的所有团队选择自己想要的技术栈，我们就会遇到一个困境，该如何平衡团队选择的自主性和公司技术栈的统一性呢？<br>Erik：组织的管理层应当设定一个技术方向，并设立一套宽泛的原则以做决策。公司所有团队都使用类似的技术栈所带来的优势很明显：在购买软件使用权时能够有更好的议价；在新需求出现时，团队能够迅速重组，提高组织的适应性；技术挑战一经解决，技术知识点传递给公司上下全体成员。</p><p>这么做也有缺点。随着市场需求和公司所提供的解决方案复杂化，对团队技术栈的多样性要求也就越高。也就是说，基础原则是确立一个技术栈方向，但同时也要给予团队做出偏离指示的自治能力。不过团队也要阐述清楚不遵循公司技术大方向的原因所在。</p><p>Miteski：微服务之类的低耦合方法可以让不同团队使用不同的编程语言搭建服务或系统部件，这种层级的灵活性的确可以带来一定的优势，那么我们应该在何时利用这种优势呢？这种情况下是否也有基础准则？通常情况下工程师都会知道该怎么做，但在创建新的技术栈时他们的目的可能并不单纯。我见过有的工程师想用 Go 来编写服务，仅仅因为他们觉得 Go 这个新语言看起来很酷，想要学习 Go。<br>Erik：低耦合基本不会出错，而多种编程语言也会促进公司发展。最关键的是变化，从一个微小的变化开始，如果效果好，那我们就从中学习，鼓励其他团队在其基础上发展。根据公司及代码的规模不同，公司整体的技术栈向一个新方向转变所需时间也各不相同。持续的演变与渐进的转化总比一刀斩从头开始的痛苦要小。这种情况下我们的基本原则是，限制并规划这些新语言或新技术的探索，在系统或服务的非关键部分进行测试。随时切断这些实验服务而不影响主要功能。让发展与技术变革从服务末梢开始，从最微不足道的影响逐步向服务中心靠拢，让全部系统和代码基础缓慢发生变化。在已经开始了向内推动且尚未到达系统核心的变更浪潮后，我们很少会再开创全新的发展潮流。</p><p>聚焦于让我们能够以可持续的方式高速发展的东西，同时也不要忽视运维的作用，这样才能更快、更安全，也更快乐地交付更高价值的产品。</p><p>Miteski: 多谢！我很享受这次的对话。我相信任何的公司都应该不时来读一读这篇文章。<br>Erik: 谢谢，记得在你重温《独角兽项目》时再来看看我。</p><p>原文链接</p><p><a href="https://mp.weixin.qq.com/s/eotJIICri7kaz8R6yRnU_Q">https://mp.weixin.qq.com/s/eotJIICri7kaz8R6yRnU_Q</a><br><a href="https://www.infoq.com/articles/tech-stack-decisions/">https://www.infoq.com/articles/tech-stack-decisions/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术选型时应该遵循的原则和应该避免的陷阱&quot;&gt;&lt;a href=&quot;#技术选型时应该遵循的原则和应该避免的陷阱&quot; class=&quot;headerlink&quot; title=&quot;技术选型时应该遵循的原则和应该避免的陷阱&quot;&gt;&lt;/a&gt;技术选型时应该遵循的原则和应该避免的陷阱&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Tech理念" scheme="http://example.com/categories/Tech%E7%90%86%E5%BF%B5/"/>
    
    
    <category term="技术好文" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%A5%BD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>解耦Spring之后该如何高效的进行事件通知</title>
    <link href="http://example.com/2022/08/21/publish_and_subscribe_without_spring/"/>
    <id>http://example.com/2022/08/21/publish_and_subscribe_without_spring/</id>
    <published>2022-08-21T12:15:43.000Z</published>
    <updated>2022-08-21T12:16:56.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解耦Spring之后该如何高效的进行事件通知"><a href="#解耦Spring之后该如何高效的进行事件通知" class="headerlink" title="解耦Spring之后该如何高效的进行事件通知"></a>解耦Spring之后该如何高效的进行事件通知</h1><p>Spring 作为重量级生产级的框架，在日常的企业开发过程中被广泛应用，其提供的 IOC ，AOP ，WebMVC等给开发带来了极大的便利。但在使用的过程中，逐渐会发现，随着开发迭代的不断深入，Spring 逐渐变成了开发过程中不可缺少的一个环节，Spring 所提供的类，方法在项目中遍地都是。慢慢的，框架的使用似乎逐渐成了业务逻辑一部分，想要脱离 Spring 变得及其的困难，甚至可行性变成了零。不光如此，相信很多做过框架升级的伙伴也发现了其中难以察觉的坑，一旦某一个版本出现不确定，项目就可能直接运行失败。等等诸如此类的问题，不得不思考，Spring 真的这么需要吗？（后续会有关于 简单实现一个 Spring 的分享出来，知己知彼，方能百战不殆）</p><p>参考很多框架中间件的实现，就不难发现，基本很少有中间件会在实现的时候直接去使用 Spring ，而是在通过后续的开发，独立出一个专门用于适配Spring的版本。我想作为这些中间件的开发创作者也大都有上面类似的顾虑吧，还有就是 Spring 的启动时间确实是难以接受，对于一些需要快速启动，低故障恢复时延的项目，Spring的接入启动好像并不是很能让人满意。</p><p>好了，说了这么多拙见，似乎离我们的标题越来越远了…言归正传，Spring大家既然都用过了，那它的事件通知应该也都用过的吧。不知道有没有发现一个问题，就是当你使用 ApplicationPublisher 的时候，你首先得知道这个事件是通过谁发送出去的，然后接收者得知道自己接受的是什么事件。但是我们所用的事件通知，所关注的本身是事件，对于接收者来说没有一点问题，但是要把一个事件发送出去，我们得先知道知道发送者是谁，是不是觉得有些奇怪？那要是当事件多了之后呢？</p><p>我们希望的是，既然是使用的事件通知这么一个东西，那么在开发的时候我想关注的只是事件本身，并不希望使用一个事件，就要显示的再去使用这个事件的发送者，同时回到我们前面说的，如果不使用 Spring ，那我们该怎么去实现事件通知呢？</p><p>可能有熟悉GOF23的小伙伴会脱口而出：观察者模式。没错，最根本额设计实现思想就是观察者模式，再结合我们前面说到的，要在使用的时候只关注事件本身，而不需要知道什么事件由什么发送者发出的，来看看我是怎么实现的。</p><p>事件通知的三板斧我们先定义好：事件，发送者，订阅者。</p><p>首先是事件的定义，我们使用一个标记类去定义这个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Event implements Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件基类定义好了之后我们去定义事件的发送者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public interface EventPublisher extends Closeable &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义好当前$&#123;@link EventPublisher&#125;发送的是什么类型的事件.</span><br><span class="line">     * @return &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Class&lt;? extends Event&gt; getEventType();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 给当前的发布者添加对其发布事件感兴趣的订阅者（通过一个订阅者列表实现事件广播）.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addSubscriber(Subscriber subscriber);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从订阅者列表中删除一个订阅者.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void removeSubscriber(Subscriber subscriber);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     *</span><br><span class="line">     * @param event &#123;@link Event&#125;</span><br><span class="line">     * @return publish event is success</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean publish(Event event);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Notify listener.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     * @param event      &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void notifySubscriber(Subscriber subscriber, Event event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义这个事件的订阅者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subscriber&lt;T extends Event&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 事件通知的回调.</span><br><span class="line">     *</span><br><span class="line">     * @param event &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void onEvent(T event);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前订阅者所关注的事件类型.</span><br><span class="line">     *</span><br><span class="line">     * @return Class which extends &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract Class&lt;? extends Event&gt; subscribeType();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理事件的线程池（用于提高订阅者事件的处理能力）.</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@link Executor&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Executor executor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就定义好了事件，发布者，订阅者三个角色的基类。通过我们定义的 EventPublisher 来对 Event 事件进行发布，同时再运行的时候再把 Subscriber 通过 EventPublisher 中定义的 addSubscriber 方法注册到对应的 EventPublisher 中的订阅者列表中去，这样基本的观察者模式就成型了，同时，由于我们使用的是订阅者列表，实现了订阅者和发布者之间 N：1 的映射关系，以及当事件来临时，使得广播成为了可能。</p><p>好了，这样问题就来了，按照现在的逻辑，那是不是在发布事件的时候还是得显示的使用事件相关的 EventPublisher 实现呢？是的，按照现在的逻辑确实需要这么做，那我们怎么去解决这个问题呢？</p><p>既然说我们不想每次在发布一个事件的时候就要去显示的声明当前事件的发布者，那我们是不是可以想办法，在一个中转站把事件和事件发布者关联起来，将他们之间的一对一的映射关系保存在其中，这样我们每次发布事件的时候就可以通过同一个中转站去发送事件，发送的时候只需要通过映射关系去找到对应的 EventPublisher 就好了。同样的，由于 Subscriber 和 Event 的映射关系也是一对一的，所以我们便可以通过中转站将 Subscriber 注册到对应的 EventPublisher 中去了，我们来看一下这个所谓的中转站如何设计实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class UnifiedNotifyCenter   &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(UnifiedNotifyCenter.class);</span><br><span class="line">    </span><br><span class="line">    private final Map&lt;String, EventPublisher&gt; publisherMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">    </span><br><span class="line">    public UnifiedNotifyCenter(Collection&lt;EventPublisher&gt; publishers) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可以在此初始化 publisherMap</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 往对应的$&#123;@link EventPublisher&#125; 中注册订阅者.</span><br><span class="line">     * @param subscriber</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void registerSubscriber(final Subscriber subscriber) &#123;</span><br><span class="line">        String topic &#x3D; subscriber.subscribeType().getCanonicalName();</span><br><span class="line">        EventPublisher publisher &#x3D; publisherMap.get(topic);</span><br><span class="line">        if (Objects.nonNull(publisher)) &#123;</span><br><span class="line">            publisher.addSubscriber(subscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     * @param event</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean publishEvent(final Event event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return publishEvent(event.getClass(), event);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;There was an exception to the message publishing : &quot;, ex);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     * @param eventType</span><br><span class="line">     * @param event</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean publishEvent(final Class&lt;? extends Event&gt; eventType, final Event event) &#123;</span><br><span class="line">        String topic &#x3D; eventType.getCanonicalName();</span><br><span class="line">        EventPublisher publisher &#x3D; publisherMap.get(topic);</span><br><span class="line">        if (!Objects.isNull(publisher)) &#123;</span><br><span class="line">            return publisher.publish(event);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.warn(&quot;[UnifiedNotifyCenter] There is no [&#123;&#125;] publisher for this event.&quot;, topic);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是我定义的 中转站，通过一个Hash映射 Event 和 EventPublisher ，然后把注册和事件发布的操作都委托给这里的 UnifiedNotifyCenter。这样，我们就解决了每次事件发布都需要声明事件对应发布者的问题，并将注册订阅者和事件发布的操作委托到了 UnifiedNotifyCenter 中去。同时，由于 Subscriber 必须要注册到 EventPublisher 中才能进行事件通知，若没有中间这个 UnifiedNotifyCenter ，那么将会由于 EventPublisher 必须执行的注册操作而导致 EventPublisher 与 Subscriber 耦合到一起，在引入了 UnifiedNotifyCenter 之后，解决了两者之间的必然的耦合关系。</p><p>由于事件与事件发布者之间的关系需要提前维护，所以我们就需要通过某种方式将两者维护起来，可以通过 JDk 自带的 ServiceLoader 去在构造函数中初始化彼此的映射关系。或者你若想在 Spring 中使用此设计，那你便可以在构造函数中通过依赖注入的方式去初始化这个映射。</p><p>下面以 JDK 的ServiceLoader 为例，展示一下如何通过 ServiceLoader 去初始化：</p><p>首先为了方便演示，我们先定义一个通用的 事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class GeneralEvent extends Event&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再定一个发送此类事件的发布者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GeneralEventPublisher extends BaseEventPublisher &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;? extends Event&gt; getEventType() &#123;</span><br><span class="line">        return GeneralEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要使用 JDK 的ServiceLoader， 那我们要先在 resouces 的META-INF.services 下面新建一个用于查找的文档，名称为我们的 EventPublisher 基类：</p><p>com.example.demo.event.publisher.EventPublisher</p><p>其中我们在文档中定义我们的 GeneralEventPublisher ：</p><p>com.example.demo.event.publisher.GeneralEventPublisher</p><p>最后，我们在 UnifiedNotifyCenter 的无参构造函数中通过 ServiceLoader 去加载并初始化映射关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public UnifiedNotifyCenter() &#123;</span><br><span class="line">       ServiceLoader&lt;EventPublisher&gt; eventPublisherServiceLoader &#x3D; ServiceLoader.load(EventPublisher.class);</span><br><span class="line">       for (EventPublisher publisher : eventPublisherServiceLoader) &#123;</span><br><span class="line">           System.out.println( publisher.getEventType().getCanonicalName());</span><br><span class="line">           publisherMap.putIfAbsent(publisher.getEventType().getCanonicalName(), publisher);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 用于资源回收</span><br><span class="line">       Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">           if (!publisherMap.isEmpty()) &#123;</span><br><span class="line">               publisherMap.forEach((key, value) -&gt; value.shutdown());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们的一整套的时间通知机制就完成了。</p><p>为了解决事件多的时候事件处理时间的问题，我们可以采用一种类似 Reactor 模式的方式，在事件发布者内部维护一个监听线程，以及一个用于缓冲的队列，将事件产生的线程和事件分发的线程解耦开。同时，我们在前面定义 Subscriber 的时候，定义了一个 executor() 方法用于获取定义好的处理事件的线程池，来看看我是如何定义这么一个 类 Reactor模式的事件发布者的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WorkerBasedEventPublisher extends Thread implements EventPublisher &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(WorkerBasedEventPublisher.class);</span><br><span class="line">    </span><br><span class="line">    private final ConcurrentHashSet&lt;Subscriber&gt; subscribers &#x3D; new ConcurrentHashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private final BlockingQueue&lt;Event&gt; queue &#x3D; new ArrayBlockingQueue&lt;&gt;(1024);</span><br><span class="line">    </span><br><span class="line">    private volatile boolean shutdown &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public WorkerBasedEventPublisher() &#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ConcurrentHashSet&lt;Subscriber&gt; getSubscribers() &#123;</span><br><span class="line">        return subscribers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void addSubscriber(Subscriber subscriber) &#123;</span><br><span class="line">        subscribers.add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void removeSubscriber(Subscriber subscriber) &#123;</span><br><span class="line">        subscribers.remove(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean publish(Event event) &#123;</span><br><span class="line">        boolean success &#x3D; this.queue.offer(event);</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            System.out.println(&quot;添加发布时间失败&quot;);</span><br><span class="line">            LOGGER.warn(&quot;[WorkerBasedEventPublisher # publish] Error to publish event : [&#123;&#125;]&quot;,event.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notifySubscriber(Subscriber subscriber, Event event) &#123;</span><br><span class="line">        </span><br><span class="line">        LOGGER.debug(&quot;[ UnifiedNotifyCenter ] the &#123;&#125; will received by &#123;&#125;&quot;, event, subscriber);</span><br><span class="line">        final Runnable job &#x3D; () -&gt; subscriber.onEvent(event);</span><br><span class="line">        </span><br><span class="line">        final Executor executor &#x3D; subscriber.executor();</span><br><span class="line">        </span><br><span class="line">        if (executor !&#x3D; null) &#123;</span><br><span class="line">            executor.execute(job);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                job.run();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOGGER.error(&quot;Event callback exception: &quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        openEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void openEventHandler() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int waitTimes &#x3D; 60;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                if (shutdown || hasSubscriber() || waitTimes &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 防止 CPU 空转</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                waitTimes--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                if (shutdown) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                final Event event &#x3D; queue.take();</span><br><span class="line">                receiveEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;Event listener exception : &quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void receiveEvent(Event event) &#123;</span><br><span class="line">        if (!hasSubscriber()) &#123;</span><br><span class="line">            LOGGER.warn(&quot;[NotifyCenter] the &#123;&#125; is lost, because there is no subscriber.&quot;, event.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            notifySubscriber(subscriber, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean hasSubscriber() &#123;</span><br><span class="line">        return CollectionUtils.isNotEmpty(subscribers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        this.shutdown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 这边只是简单的将事件队列清空了，其实可以在调用销毁的钩子的时候将事件处理结束，当&#x2F;&#x2F; 然这需要看具体的业务需求</span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当需要提高处理事件的能力的时候我们就可以直接继承 WorkerBasedEventPublisher 这个事件发布者了。</p><p>好了，至此一个属于我们自己的发布订阅模型就实现结束了，在使用的时候我们只需要做如下几步：</p><ol><li>定义好事件</li><li>根据需求选择合适的 EventPublisher 定义好事件发布者</li><li>定义好事件订阅者</li><li>将事件订阅者通过统一通知中心注册到对应事件的发布者中去</li><li>通过JDK的spi或者其他的扩展机制，将事件与事件发布者的映射关系初始化到统一通知中心中去</li><li>通过统一通知中心发布事件</li></ol><p>当然，本篇文章虽然说的是解耦 Spring 之后事件通知如何进行，但在 Spring 项目中我们也是可以使用这个发布订阅模型的实现的。</p><p>关于事件通知实现的内容讲到这里就结束了，肯定还有更好的实现方式存在，这不重要，重要的是你是否有想法，是否有跳出框架后该怎么做的想法。</p><p>好的，谢谢您花了很多时间看完这篇文章，有建议的欢迎一起来探讨。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解耦Spring之后该如何高效的进行事件通知&quot;&gt;&lt;a href=&quot;#解耦Spring之后该如何高效的进行事件通知&quot; class=&quot;headerlink&quot; title=&quot;解耦Spring之后该如何高效的进行事件通知&quot;&gt;&lt;/a&gt;解耦Spring之后该如何高效的进行事件</summary>
      
    
    
    
    <category term="发布订阅模型" scheme="http://example.com/categories/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="发布订阅模型" scheme="http://example.com/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="Reactor模式" scheme="http://example.com/tags/Reactor%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nacos2.x Naming</title>
    <link href="http://example.com/2021/07/07/nacos%E2%80%94naming/"/>
    <id>http://example.com/2021/07/07/nacos%E2%80%94naming/</id>
    <published>2021-07-07T13:55:43.000Z</published>
    <updated>2021-08-26T12:51:22.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅析-Nacos2-x-注册客户端启动流程"><a href="#浅析-Nacos2-x-注册客户端启动流程" class="headerlink" title="浅析 Nacos2.x 注册客户端启动流程"></a>浅析 Nacos2.x 注册客户端启动流程</h1><p>注意：本文所有内容均是基于Nacos2.0.2版本。</p><h4 id="客户端服务注册流程"><a href="#客户端服务注册流程" class="headerlink" title="客户端服务注册流程"></a>客户端服务注册流程</h4><p>Nacos 的服务注册的统一入口在 NamingService 这个接口处定义，通过调用 registerInstance（）方法来注册。在 NacosNamingService 处实现了 NamingService 服务注册接口的基础注册方法：registerInstance（）。而其具体实现是委托给了 NacosNamingServiceDelegate ，这个类比较特殊，在 1.x 版本是没有的，是在 2.x 版本中新增了 Grpc 之后为了适配原先 1.x 版本的 Nacos-Client 而存在的，在旧版本的客户端中，NacosNamingService 的服务注册请求是交给其代理类直接去发送 Http 请求 Server 来实现服务注册的。具体的暂时不做深入。在委托类中，进行 Grpc 和 Http 分流的操作我们可以初窥一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private NamingClientProxy getExecuteClientProxy(Instance instance) &#123;</span><br><span class="line">        return instance.isEphemeral() ? grpcClientProxy : httpClientProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该还是比较易懂的，直接根据服务实例的节点类型来判断，是临时节点的则直接走 GRPC ，否则 Http。<br>在处理 Grpc 请求的代理类 NamingGrpcClientProxy 中 继续调用其 registerService（）方法，然后通过 requestToServer（）封装 Grpc 请求，最后由 GrpcClient 去请求 Nacos-Server 注册服务。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>我们将会基于我们的流程，来分析 NamingService 实现类以及其代理类初始化流程。</p><p>一般的，我们会通过一个工厂方法 NamingFactory，来创建我们的 NamingService 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line"></span><br><span class="line">properties.setProperty(&quot;serverAddr&quot;, &quot;127.0.0.1:8848&quot;); </span><br><span class="line"></span><br><span class="line">NamingService naming &#x3D; NamingFactory.createNamingService(properties);</span><br></pre></td></tr></table></figure><p>在创建实例的时候我们会传入一个 Properties 对象到我们的 NamingService 的构造方法中来初始化我们的 NamingService 对象。我们看一下其实现类 NacosNamingService 的构造函数是怎么处理的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public NacosNamingService(Properties properties) throws NacosException &#123;</span><br><span class="line">       init(properties);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void init(Properties properties) throws NacosException &#123;</span><br><span class="line">       ValidatorUtils.checkInitParam(properties); &#x2F;&#x2F; 1 检查 ContextPath 的合法性</span><br><span class="line">       this.namespace &#x3D; InitUtils.initNamespaceForNaming(properties); &#x2F;&#x2F; 2 初始化 namespace</span><br><span class="line">       InitUtils.initSerialization(); &#x2F;&#x2F; 3 主要是为了序列化安全</span><br><span class="line">       InitUtils.initWebRootContext(properties); &#x2F;&#x2F; 4 初始化 contextPath</span><br><span class="line">       initLogName(properties); &#x2F;&#x2F; 5 初始化日志前缀名称</span><br><span class="line">       </span><br><span class="line">       this.changeNotifier &#x3D; new InstancesChangeNotifier(); &#x2F;&#x2F; 6</span><br><span class="line">       NotifyCenter.registerToPublisher(InstancesChangeEvent.class, 16384); &#x2F;&#x2F; 7</span><br><span class="line">       NotifyCenter.registerSubscriber(changeNotifier); &#x2F;&#x2F; 8</span><br><span class="line">       this.serviceInfoHolder &#x3D; new ServiceInfoHolder(namespace, properties); &#x2F;&#x2F; 9</span><br><span class="line">       this.clientProxy &#x3D; new NamingClientProxyDelegate(this.namespace, serviceInfoHolder, properties, changeNotifier); &#x2F;&#x2F; 10</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们依次来看看，NacosNamingService 构造函数调用了一个 init（）方法，其中主要做了 11 件事情。其中，我们主要看后面五个。<br>首先看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.changeNotifier &#x3D; new InstancesChangeNotifier(); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><p>这里会新 new 一个 InstancesChangeNotifier 对象，见名知意，大概猜出它是用于实例变更的通知的，这一步我们在初始化流程中先不做详细分析，在后面会单独出来一个章节去解释这个 NotifyCenter 和 一系列的Notifier,Subscriber的妙用。抛开业务流程，这部分个人觉得还是可以品一下的。</p><p>好，那这样我们就直接跳到 init() 方法的最后两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化 ServiceInfoHolder</span><br><span class="line">this.serviceInfoHolder &#x3D; new ServiceInfoHolder(namespace, properties);</span><br><span class="line">&#x2F;&#x2F; 初始化 NamingClientProxyDelegate</span><br><span class="line">this.clientProxy &#x3D; new NamingClientProxyDelegate(this.namespace, serviceInfoHolder, properties, changeNotifier);</span><br></pre></td></tr></table></figure><p>看一下 ServiceInfoHolder ，这里就体现了命名规范的重要性了，我们还是可以使用那个词 – 见名知意，这个是一个服务信息的持有者，在我们将我们的服务注册到 Nacos 上之后，那么这个类将是我们交互访问最多的一个类。它的主要工作内容就是负责缓存，本地化服务信息以及预防故障的冗余处理，来看一下它比较重要的两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于缓存</span><br><span class="line">private final ConcurrentMap&lt;String, ServiceInfo&gt; serviceInfoMap;</span><br><span class="line">&#x2F;&#x2F; 用于故障冗余</span><br><span class="line">private final FailoverReactor failoverReactor;</span><br></pre></td></tr></table></figure><p>不难看出，ServiceInfoHolder 主要做的事情就是对服务信息的缓存以及故障冗余。<br>下面再来看一下他的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ServiceInfoHolder(String namespace, Properties properties) &#123;</span><br><span class="line">       initCacheDir(namespace, properties);</span><br><span class="line">       &#x2F;&#x2F; 判断是否需要在启动的时候读取缓存的配置</span><br><span class="line">       if (isLoadCacheAtStart(properties)) &#123;</span><br><span class="line">           this.serviceInfoMap &#x3D; new ConcurrentHashMap&lt;String, ServiceInfo&gt;(DiskCache.read(this.cacheDir));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.serviceInfoMap &#x3D; new ConcurrentHashMap&lt;String, ServiceInfo&gt;(16);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 初始化一个 FailoverReactor</span><br><span class="line">       this.failoverReactor &#x3D; new FailoverReactor(this, cacheDir);</span><br><span class="line">       &#x2F;&#x2F; 判断是否配置了空消息推送保护，开启了的时候在服务端推送错误或者空的服务信息的时候&#x2F;&#x2F; 会忽略.</span><br><span class="line">       this.pushEmptyProtection &#x3D; isPushEmptyProtect(properties);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很简单，初始化了 Map 和故障切换，还有就是根据配置判断是否需要忽略服务端无效的推送信息。</p><p>回到 init()方法，这是一个决定我们能否执行注册订阅等请求的一个类 – NamingClientProxy ，这个类的作用其实就是一个我们客户端中 1.x 和 2.x 的请求的适配和分发。我们知道，在 1.x 和 2.x 两个版本迭代的最大区别之一便是客户端服务端之间请求方式的改变，从原本的 http 优化到了 grpc 的请求形式。由于我们分析的主要是 2.x 的版本，所以客户端服务端均是默认 grpc 。当然，对于低版本客户端连接高版本服务端是可以兼容的，但反过来就不行了。</p><p>来，直接看一下 NamingClientProxyDelegate 的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public NamingClientProxyDelegate(String namespace, ServiceInfoHolder serviceInfoHolder, Properties properties,</span><br><span class="line">            InstancesChangeNotifier changeNotifier) throws NacosException &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化一个ServiceInfo更新的服务</span><br><span class="line">        this.serviceInfoUpdateService &#x3D; new ServiceInfoUpdateService(properties, serviceInfoHolder, this,</span><br><span class="line">                changeNotifier);</span><br><span class="line">        &#x2F;&#x2F; 初始化 服务端地址管理的服务        </span><br><span class="line">        this.serverListManager &#x3D; new ServerListManager(properties, namespace);</span><br><span class="line">        &#x2F;&#x2F; 将 NacosNamingService 传递过来的 ServiceInfoHolder 指向自己内部的 ServiceInfoHolder.</span><br><span class="line">        this.serviceInfoHolder &#x3D; serviceInfoHolder;</span><br><span class="line">        &#x2F;&#x2F; 安全管理</span><br><span class="line">        this.securityProxy &#x3D; new SecurityProxy(properties,</span><br><span class="line">                NamingHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line">        initSecurityProxy();</span><br><span class="line">        &#x2F;&#x2F; 初始化Http方式的请求服务</span><br><span class="line">        this.httpClientProxy &#x3D; new NamingHttpClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br><span class="line">        &#x2F;&#x2F; 初始化Grpc方式的请求服务</span><br><span class="line">        this.grpcClientProxy &#x3D; new NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们直接看第一行和最后一行，中间的部分操作对于我们分析 2.x 的业务流程可以省略，有兴趣的读者可以自行去翻阅源码。首先看的是这个叫做 ServiceInfoUpdateService 的服务的作用。直接去到他的构造函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ServiceInfoUpdateService(Properties properties, ServiceInfoHolder serviceInfoHolder,</span><br><span class="line">            NamingClientProxy namingClientProxy, InstancesChangeNotifier changeNotifier) &#123;</span><br><span class="line">        this.executor &#x3D; new ScheduledThreadPoolExecutor(initPollingThreadCount(properties),</span><br><span class="line">                new NameThreadFactory(&quot;com.alibaba.nacos.client.naming.updater&quot;));</span><br><span class="line">        this.serviceInfoHolder &#x3D; serviceInfoHolder;</span><br><span class="line">        this.namingClientProxy &#x3D; namingClientProxy;</span><br><span class="line">        this.changeNotifier &#x3D; changeNotifier;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在构造器中初始化了一个用于任务调度的线程池 – ScheduledThreadPoolExecutor ，在向 ServiceInfoUpdateService 的 scheduleUpdateIfAbsent() 方法的时候便会使用这个内部的线程池去做一些更新注册服务相关的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleUpdateIfAbsent(String serviceName, String groupName, String clusters) &#123;</span><br><span class="line">        String serviceKey &#x3D; ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);</span><br><span class="line">        if (futureMap.get(serviceKey) !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (futureMap) &#123;</span><br><span class="line">            if (futureMap.get(serviceKey) !&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ScheduledFuture&lt;?&gt; future &#x3D; addTask(new UpdateTask(serviceName, groupName, clusters));</span><br><span class="line">            futureMap.put(serviceKey, future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private synchronized ScheduledFuture&lt;?&gt; addTask(UpdateTask task) &#123;</span><br><span class="line">        return executor.schedule(task, DEFAULT_DELAY, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在更新任务 UpdateTask 的run() 方法中，更新的对象便是我们之前分析的 ServiceInfoHolder 。</p><p>再来看 NamingGrpcClientProxy ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.grpcClientProxy &#x3D; new NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,</span><br><span class="line">                serviceInfoHolder);</span><br></pre></td></tr></table></figure><p>这段代码主要便是初始化 NamingGrpcClientProxy 这个 Grpc 请求的执行类，期间涉及到 Rpc 初始化和启动的流程，其内容篇幅比较长，我们会在后面单独起一个章节去分析，在这我们先简单看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造器</span><br><span class="line">public NamingGrpcClientProxy(String namespaceId, SecurityProxy securityProxy, ServerListFactory serverListFactory,</span><br><span class="line">            Properties properties, ServiceInfoHolder serviceInfoHolder) throws NacosException &#123;</span><br><span class="line">        super(securityProxy, properties);</span><br><span class="line">        this.namespaceId &#x3D; namespaceId;</span><br><span class="line">        &#x2F;&#x2F; 用于标识一个 RpcClient</span><br><span class="line">        this.uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">        &#x2F;&#x2F; rpc请求超时时间</span><br><span class="line">        this.requestTimeout &#x3D; Long.parseLong(properties.getProperty(CommonParams.NAMING_REQUEST_TIMEOUT, &quot;-1&quot;));</span><br><span class="line">        Map&lt;String, String&gt; labels &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">        labels.put(RemoteConstants.LABEL_SOURCE, RemoteConstants.LABEL_SOURCE_SDK);</span><br><span class="line">        labels.put(RemoteConstants.LABEL_MODULE, RemoteConstants.LABEL_MODULE_NAMING);</span><br><span class="line">        &#x2F;&#x2F; 创建一个 RpcClient 用于 Rpc 请求</span><br><span class="line">        this.rpcClient &#x3D; RpcClientFactory.createClient(uuid, ConnectionType.GRPC, labels);</span><br><span class="line">        &#x2F;&#x2F; 在 RpcClient 中会有链接结果的回调，这里是将自己注册到对应的 Linstener 中，用于相关事件发生时的回调</span><br><span class="line">        this.namingGrpcConnectionEventListener &#x3D; new NamingGrpcConnectionEventListener(this);</span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        start(serverListFactory, serviceInfoHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rpc请求客户端的启动，我们放在后面分析</span><br><span class="line">private void start(ServerListFactory serverListFactory, ServiceInfoHolder serviceInfoHolder) throws NacosException &#123;</span><br><span class="line">        rpcClient.serverListFactory(serverListFactory);</span><br><span class="line">        rpcClient.start();</span><br><span class="line">        &#x2F;&#x2F; 向 RpcClient 注册一个用于处理服务端推送的 Handler</span><br><span class="line">        rpcClient.registerServerRequestHandler(new NamingPushRequestHandler(serviceInfoHolder));</span><br><span class="line">        &#x2F;&#x2F; 向 RpcClient 注册一个用于连接建立与断开的监听器</span><br><span class="line">        rpcClient.registerConnectionListener(namingGrpcConnectionEventListener);</span><br><span class="line">        &#x2F;&#x2F; 向消息中心注册自己</span><br><span class="line">        NotifyCenter.registerSubscriber(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程的目的是比较清晰的，初始化一个带有特殊标记（uuid）的 rpcClient ，这个 rpcClient 将负责后续所有的 Grpc 请求。其中，事件注册占这中间代码量的近一半，确实，Nacos 自己定义的这一套内部的事件处理流程很意思，实现了基于 EDA 与 观察者模式的事件架构，个人比较喜欢这一块的思想，我们也会在后续起一个章节去分析他是如何通过自己内部的这个 NotifyCenter 来解耦繁多的应用组件的。</p><p>到这，Nacos 注册客户端启动流程就基本结束了，后续的 API 操作便是依托在这个流程之上来运行的。期间断断续续的再写，有很多讲的不到位的地方。这是我们整个 Nacos 旅程的开胃菜，我们会在后面的章节中慢慢的一点点的去啃食，RpcClient怎么启动的？NotifyCenter是如何工作的？等等一系列的疑问我们会慢慢分析。</p><p>总结，答题的流程是比较简单的，内容大体如下图：</p><p><img src="/images/nacos_Client%E6%B3%A8%E5%86%8C%E9%83%A8%E5%88%86%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="流程图"></p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浅析-Nacos2-x-注册客户端启动流程&quot;&gt;&lt;a href=&quot;#浅析-Nacos2-x-注册客户端启动流程&quot; class=&quot;headerlink&quot; title=&quot;浅析 Nacos2.x 注册客户端启动流程&quot;&gt;&lt;/a&gt;浅析 Nacos2.x 注册客户端启动流程&lt;/</summary>
      
    
    
    
    <category term="Nacos" scheme="http://example.com/categories/Nacos/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
    <category term="注册中心" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Springboot自动装配</title>
    <link href="http://example.com/2020/11/21/springboot_autowired/"/>
    <id>http://example.com/2020/11/21/springboot_autowired/</id>
    <published>2020-11-21T05:55:34.000Z</published>
    <updated>2021-08-26T12:23:36.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关知识介绍"><a href="#相关知识介绍" class="headerlink" title="相关知识介绍"></a>相关知识介绍</h2><p>首先我们先来简单认识一下 @Import 这个注解。@Import注解支持将普通的<br>Java 类注入进容器里面，将其声明称一个 bean，可以将多个 Java Config 配置类融合称一个更大的 Config 类。<br>在 spring 4.2 之前，@Import 只支持导入配置类，但在 4.2 之后 @Import 注解支持导入普通的 Java 类，并将其声明称一个 bean。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>直接导入普通的 Java 类</li><li>配合自定义的 ImportSelector 使用</li><li>配合 ImportBeanDefinitionRegister 使用</li></ol><h4 id="直接导入普通-Java-类"><a href="#直接导入普通-Java-类" class="headerlink" title="直接导入普通 Java 类"></a>直接导入普通 Java 类</h4><p>我们先简单创建一个 Springboot 应用：</p><p><img src="/images/springboot_app.png" alt="springboot_app.png"></p><p>其中 Application 是主配置类，ImportHelloWorld 是我们的测试类。<br>看一下其中代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImportHelloWorld implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化ImportHelloWorld...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 InitializingBean 用于在当前类被容器初始化之后做一些事情，在这里我们是直接打印了一句话。在主配置类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Import(ImportHelloWorld.class)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接使用 @Import 注解来将我们的 ImportHelloWorld 注入容器之内，来看一下启动后的控制台信息：</p><p><img src="/images/springboot_demo001.png" alt="springboot_demo001.png"></p><p>可以看到我们的注解方式生效了，并成功的将 bean 初始化之后的信息输出到了控制台上。</p><h4 id="使用自定义的-ImportSelector"><a href="#使用自定义的-ImportSelector" class="headerlink" title="使用自定义的 ImportSelector"></a>使用自定义的 ImportSelector</h4><p>我们首先还是自定义一个 Java 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ImportSelectorHelloWorld implements InitializingBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化 ImportSelectorHelloWorld ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上面同样的方式，使其可以在被加载之后可以输出一些标示性的话，其次是我们自定义一个我们自己的 ImportSelector 用于注册我们定义的 ImportSelectorHelloWorld ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;xyz.turboklaus.spring.ImportSelectorHelloWorld&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方法返回了一个 String 类型的数组，在数组中我们将定义好的 ImportSelectorHelloWorld 的包地址放进去，然后我们使用 @Import 将 MyImportSelector 注入容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;ImportHelloWorld.class,MyImportSelector.class&#125;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloWorldProperties properties;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动后控制台的输出信息：</p><p><img src="/images/springboot_demo002.png" alt="springboot_demo002.png"><br>成功的输出了我们定义的信息。</p><h4 id="配合自定义的-ImportBeanDefinitionRegistrar"><a href="#配合自定义的-ImportBeanDefinitionRegistrar" class="headerlink" title="配合自定义的 ImportBeanDefinitionRegistrar"></a>配合自定义的 ImportBeanDefinitionRegistrar</h4><p>不多说，直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义 Java 类</span><br><span class="line">public class ImportBeanDefinitionRegistryHelloWorld implements InitializingBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;初始化 ImportBeanDefinitionRegistryHelloWorld ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义 ImportBeanDefinitionRegistrar</span><br><span class="line">public class MyImportBeanDefinitionRegistry implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        RootBeanDefinition definition &#x3D; new RootBeanDefinition(ImportBeanDefinitionRegistryHelloWorld.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;importBeanDefinitionRegistryHelloWorld&quot;, definition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注入 MyImportBeanDefinitionRegistry</span><br><span class="line">@Import(&#123;ImportHelloWorld.class,MyImportSelector.class,MyImportBeanDefinitionRegistry.class&#125;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看运行结果：</p><p><img src="/images/springboot_demo003.png" alt="springboot_demo003.png"></p><p>成功输出。</p><h2 id="主题-Springboot自动配置原理"><a href="#主题-Springboot自动配置原理" class="headerlink" title="主题 - - Springboot自动配置原理"></a>主题 - - Springboot自动配置原理</h2><h3 id="SpringbootApplication"><a href="#SpringbootApplication" class="headerlink" title="@SpringbootApplication"></a>@SpringbootApplication</h3><p>一切的一切都要归根到这里，从 @SpringbootApplication 注解开始说起。</p><p>@SpringBootApplication 标注在某个类上说明：</p><ul><li>这个类是 Springboot 的主配置类</li><li>Springboot 就应该运行这个类的 main 方法来启动 Springboot应用</li></ul><p>看一下这个注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters &#x3D; &#123;@Filter(</span><br><span class="line">    type &#x3D; FilterType.CUSTOM,</span><br><span class="line">    classes &#x3D; &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type &#x3D; FilterType.CUSTOM,</span><br><span class="line">    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出 @SpringbootApplication 是一个组合注解</p><ul><li>@SpringBootConfiguration：该注解表示这是一个 SpringBoot 的配置类，其实它就是一个 @Configuration 注解</li><li>@ComponentScan：开启组件扫描</li><li>@EnableAutoConfiguration：从名字就可以看出来，就是这个类开启自动配置的。嗯，自动配置的奥秘全都在这个注解里面</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>我们先来看一下它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>从它的取名可以看出这大概是一个用于自动配置包的注解，我们继续看它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终于我们看到了比较熟悉的一个注解 @Import 其中它注入了一个叫 Registrar 的类。我们在其方法上打上一个断点然后启动应用：</p><p><img src="/images/springboot_demo004.png" alt="springboot_demo004.png"></p><p>输出了我们主配置类所在包的包名。简而言之，@AutoConfigurationPackage 注解就是将主配置类所在包以及下面的所有子包里面的所有组件扫描到 Spring 容器之中，所以说，默认情况下，主配置类包以及子包之外的组件，Spring是扫描不到的。</p><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>这个注解的作用就是给当前的配置类导入另外的别的自动配置类。@Import 注入的 AutoConfigurationImportSelector ，我们通过前面 @Import 的例子知道， selectimport 就是用来返回我们需要导入的组件的全类名的数组，就如同下面方法所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return NO_IMPORTS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry &#x3D; this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下其大概的调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return EMPTY_ENTRY;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AnnotationAttributes attributes &#x3D; this.getAttributes(annotationMetadata);</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">            List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations &#x3D; this.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions &#x3D; this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations &#x3D; this.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">        List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用链大概如上1-2-3所示，其中第三步调用 SpringFactoriesLoader.loadFactoryNames 中比较关键的三步：</p><ul><li>从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</li><li>将上面获取到的信息封装成一个 Map 返回。</li><li>从返回的 Map 中通过刚才传入的 EnableAutoConfiguration.class 参数，获取该 key 下的所有值。</li></ul><p>其中的第一步就是将类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到 Spring 容器中。</p><p>至此Springboot的自动配置就完成了，其比较重要的一个文件就是  META-INF/spring.factories 。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关知识介绍&quot;&gt;&lt;a href=&quot;#相关知识介绍&quot; class=&quot;headerlink&quot; title=&quot;相关知识介绍&quot;&gt;&lt;/a&gt;相关知识介绍&lt;/h2&gt;&lt;p&gt;首先我们先来简单认识一下 @Import 这个注解。@Import注解支持将普通的&lt;br&gt;Java 类注入进</summary>
      
    
    
    
    <category term="Springboot" scheme="http://example.com/categories/Springboot/"/>
    
    
    <category term="Springboot" scheme="http://example.com/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Netty-ChannelPipeline，ChannelHandler和ChannelHandlerContext</title>
    <link href="http://example.com/2020/10/27/channelpipeline-channelhandler-channelhandlercontext/"/>
    <id>http://example.com/2020/10/27/channelpipeline-channelhandler-channelhandlercontext/</id>
    <published>2020-10-27T06:55:48.000Z</published>
    <updated>2021-08-26T12:23:36.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是ChannelPipeline？"><a href="#什么是ChannelPipeline？" class="headerlink" title="什么是ChannelPipeline？"></a>什么是ChannelPipeline？</h3><p>抽象的来说，ChannelPipeline是一个拦截或者处理 Channel 的入站和出站事件的 ChannelHandler 实例链。</p><p>具象的来说，ChannelPipeline是ChannelHandler的容器，负责管理ChannelHandler和事件的调度与拦截。</p><p>ChannelPipeline提供了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式以及ChannelPipeline中的ChannelHandlers如何进行交互。</p><p>对于每一个Channel来说，Netty会为其单独创建一个ChannelPipeline并将其与该创建的Pipeline绑定。绑定后，Channel与ChannelPipeline之间的耦合是永久的。Channel不能绑定另一条ChannelPipeline或者将当前已经绑定的ChannelPipeline与自己捆绑。当然这些个操作Netty已经帮我们做好了。</p><p>我们来看下面这一张图：<br><img src="/images/netty_pipeline.png" alt="netty_pipeline.png"></p><p>图内标注了 InboundHandler 和 OutbountHandler ，表示在ChannelPipeline 中的消息流转是有方向的。同时也展示出了这入站和出站的来源。通常来说，InboundHandler 处理由图中底部由Netty内部I/O产生的入站数据。一个入站的I/O事件将从底部向上传播，出站的I/O事件将从上往下传播，通常Netty将入站开始的地方称为头部，出站开始的地方称为尾部。</p><p>在 ChannelPipeline 传播事件时，它会判断 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。(当然，ChannelHandler 也可以同时实现 ChannelInboundHandler 接口和 ChannelOutboundHandler 接口。)</p><h4 id="ChannelPipeline源码分析"><a href="#ChannelPipeline源码分析" class="headerlink" title="ChannelPipeline源码分析"></a>ChannelPipeline源码分析</h4><p>首先来看一下ChannelPipeline的类关系图：</p><p><img src="/images/netty_channel_pipeline_class.png" alt="netty_channel_pipeline_class.png"></p><p>它的继承关系十分的简单，直接实现类也就只有一个DefaultChannelPipeline。由于ChannelPipeline的自身操作主要集中在链的操作上面，而一些例如传播事件等都是通过转发的操作进行的，我们就着重分析其链的操作。</p><p>几个常用的操作大概有下面这几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline addFirst(String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addLast(String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline remove(ChannelHandler handler);</span><br><span class="line"></span><br><span class="line">ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);</span><br></pre></td></tr></table></figure><p>从方法名字应该不难看出这些方法的作用吧。添加的方法我们这里就来分析一个addBefore（），来看一下它的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline addBefore(</span><br><span class="line">            EventExecutorGroup group, String baseName, String name, ChannelHandler handler) &#123;</span><br><span class="line">        final AbstractChannelHandlerContext newCtx;</span><br><span class="line">        final AbstractChannelHandlerContext ctx;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 做重复校验</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line">            name &#x3D; filterName(name, handler);</span><br><span class="line">            &#x2F;&#x2F; 通过名字获取ctx实例</span><br><span class="line">            ctx &#x3D; getContextOrDie(baseName);</span><br><span class="line">            &#x2F;&#x2F; 新增ChannelHandler</span><br><span class="line">            newCtx &#x3D; newContext(group, name, handler);</span><br><span class="line">            addBefore0(ctx, newCtx);</span><br><span class="line">            if (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, true);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor &#x3D; newCtx.executor();</span><br><span class="line">            if (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于ChannelPipeline支持运行期的动态修改，所以可能存在I/O线程与用户线程的并发访问或者是多个用户线程的并发访问。所以在方法内部使用了同步块。</p><p>重复性校验主要的作用是检查当前加入进来的ChannelHandler已经加进来了了，若已经加入那么这个Handler是否使用了@Sharable注解注释了，否则将会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void checkMultiplicity(ChannelHandler handler) &#123;</span><br><span class="line">        if (handler instanceof ChannelHandlerAdapter) &#123;</span><br><span class="line">            ChannelHandlerAdapter h &#x3D; (ChannelHandlerAdapter) handler;</span><br><span class="line">            if (!h.isSharable() &amp;&amp; h.added) &#123;</span><br><span class="line">                throw new ChannelPipelineException(</span><br><span class="line">                        h.getClass().getName() +</span><br><span class="line">                                &quot; is not a @Sharable handler, so can&#39;t be added or removed multiple times.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            h.added &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后是通过filterName（）这个方法对当前要添加的handler进行取名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private String filterName(String name, ChannelHandler handler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 无名字则生成一个</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return generateName(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断名字是否重复</span><br><span class="line">        checkDuplicateName(name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是核心方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx &#x3D; getContextOrDie(baseName);</span><br><span class="line">         </span><br><span class="line">newCtx &#x3D; newContext(group, name, handler);</span><br></pre></td></tr></table></figure><p>首先是通过getContextOrDie（）方法获取当前handler添加的后一个handler的handlerContext。addBefore方法针对两个handler，一个是我们要添加的handler，另一个是已经添加进去的那个handler，在方法中的表述就是newCtx和ctx。来看一下获取ctx（我们要添加进去的handler的后一个handler的handlerContext）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"> private AbstractChannelHandlerContext getContextOrDie(String name) &#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx &#x3D; (AbstractChannelHandlerContext) context(name);</span><br><span class="line">        if (ctx &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NoSuchElementException(name);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ctx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"> public final ChannelHandlerContext context(String name) &#123;</span><br><span class="line">        return context0(ObjectUtil.checkNotNull(name, &quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line"> private AbstractChannelHandlerContext context0(String name) &#123;</span><br><span class="line">        AbstractChannelHandlerContext context &#x3D; head.next;</span><br><span class="line">        while (context !&#x3D; tail) &#123;</span><br><span class="line">            if (context.name().equals(name)) &#123;</span><br><span class="line">                return context;</span><br><span class="line">            &#125;</span><br><span class="line">            context &#x3D; context.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取ctx的主要看方法3，由于在初始化的时候pipeline定义了一个头和尾，所以我们可以看到在获取的时候我们总是去除了头尾，遍历context链表，直到有匹配的。<br>回到方法1，若我们没有匹配到传入的name，则会抛出一个NoSuchElementException异常。反之则返回ctx。<br>对于新的context，是通过调用了Contex构造方法来产生一个新的context，这个方法在几个添加handler的方法中是差不多的，这就是“每当handler加入到pipeline中的时候就会生成一个对应的contex”。<br>然后是正式的将我们构造好的context加入到当前的context链中去的操作，通过方法addBefore0（）实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void addBefore0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) &#123;</span><br><span class="line">        newCtx.prev &#x3D; ctx.prev;</span><br><span class="line">        newCtx.next &#x3D; ctx;</span><br><span class="line">        ctx.prev.next &#x3D; newCtx;</span><br><span class="line">        ctx.prev &#x3D; newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是普通的链表操作，当前context持有的前后context引用的变换。</p><p>接着看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">if (!registered) &#123;</span><br><span class="line">        newCtx.setAddPending();</span><br><span class="line">        callHandlerCallbackLater(newCtx, true);</span><br><span class="line">        return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是代码块1，这里对Channel是否已经注册到Eventloop进行了判断，若未注册，将handler的状态由INIT–&gt;ADD_PENDING，并将添加Handler这个事件加入到一个专门处理延迟事件的链表中（Channel注册后需要处理的任务）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) &#123;</span><br><span class="line">       assert !registered;</span><br><span class="line">       &#x2F;&#x2F; 判断是否是添加handler的事件</span><br><span class="line">       PendingHandlerCallback task &#x3D; added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx);</span><br><span class="line">       PendingHandlerCallback pending &#x3D; pendingHandlerCallbackHead;</span><br><span class="line">       if (pending &#x3D;&#x3D; null) &#123;</span><br><span class="line">           pendingHandlerCallbackHead &#x3D; task;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 将当前task加入链尾</span><br><span class="line">           while (pending.next !&#x3D; null) &#123;</span><br><span class="line">               pending &#x3D; pending.next;</span><br><span class="line">           &#125;</span><br><span class="line">           pending.next &#x3D; task;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看一下这个task的真面目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">private abstract static class PendingHandlerCallback implements Runnable &#123;</span><br><span class="line">        final AbstractChannelHandlerContext ctx;</span><br><span class="line">        PendingHandlerCallback next;</span><br><span class="line"></span><br><span class="line">        PendingHandlerCallback(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">            this.ctx &#x3D; ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        abstract void execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现类</span><br><span class="line">private final class PendingHandlerAddedTask extends PendingHandlerCallback &#123;</span><br><span class="line">        PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">            super(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        void execute() &#123;</span><br><span class="line">            EventExecutor executor &#x3D; ctx.executor();</span><br><span class="line">   &#x2F;&#x2F; 判断执行的线程是否是原本分配的线程</span><br><span class="line">            if (executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAdded0(ctx);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">&#x2F;&#x2F; 执行callHandlerAdded0(ctx)</span><br><span class="line">                    executor.execute(this);</span><br><span class="line">                &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">                    if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(</span><br><span class="line">                                &quot;Can&#39;t invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;.&quot;,</span><br><span class="line">                                executor, ctx.name(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">&#x2F;&#x2F; 事件执行异常，将新加的handlerContext从列表中移除</span><br><span class="line">                    atomicRemoveFromHandlerList(ctx);</span><br><span class="line">&#x2F;&#x2F;设置handler的状态为REMOVE_COMPLETE</span><br><span class="line">                    ctx.setRemoved();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就是其添加的时候定义的一个task，来看这个task执行的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ctx.callHandlerAdded();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">           &#x2F;&#x2F; ...省略异常之后handler的移除操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">final void callHandlerAdded() throws Exception &#123;</span><br><span class="line">        if (setAddComplete()) &#123;</span><br><span class="line">            handler().handlerAdded(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3 设置handler的状态为ADD_COMPLETE</span><br><span class="line"> final boolean setAddComplete() &#123;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            int oldState &#x3D; handlerState;</span><br><span class="line">            if (oldState &#x3D;&#x3D; REMOVE_COMPLETE) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>task的内容主要是通知这个handler被加进来了。<br>在方法2中，我们必须在调用handlerAdded之前调用setAddComplete。<br>否则，如果handlerAdded方法生成任何pipeline事件ctx.handler（）都会错过它们，因为状态不允许。</p><p>以上是对当前Channel还未注册到Eventloop是的处理，若已经注册了，则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventExecutor executor &#x3D; newCtx.executor();</span><br><span class="line">if (!executor.inEventLoop()) &#123;</span><br><span class="line">         callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">         return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取绑定的exector，再判断这个excutor是否是自己注册时候绑定的eventloop（），若是，则继续执行上面的callHandlerAdded0（）方法去通知这个handler已经添加了，若不是channel注册时候绑定的那个eventloop，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerAddedInEventLoop(final AbstractChannelHandlerContext newCtx, EventExecutor executor) &#123;</span><br><span class="line">        newCtx.setAddPending();</span><br><span class="line">        executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                callHandlerAdded0(newCtx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这了你会发现怎么这么眼熟，没错，这里就是用exector去执行了handler添加通知的事情，和上面一样的操作。</p><p>addBefore的分析到这就结束了，由于其他的一些操作与这个都是大同小异，对于其他的操作这里就不自赘述了，至此，ChannelPipeline就分析结束了。</p><h3 id="什么是ChannelHandler？"><a href="#什么是ChannelHandler？" class="headerlink" title="什么是ChannelHandler？"></a>什么是ChannelHandler？</h3><p>正如上一小节所说的ChannelHandler是用于拦截或者处理Channel的入站和出站事件的。它可以选择性的拦截和处理自己感兴趣的事件，也可以通过透传和终止事件的传递。基于ChannelHandler接口，用户可以方便的进行业务逻辑定制，例如打印日志，统一封装异常信息，性能统计和消息编解码等。</p><p>ChannelHandler支持两种注解：</p><ul><li>Sharable：允许多个ChannelPipeLine共用同一个ChannelHandler。</li><li>Skip：被Skip注解的方法不会被调用，直接忽略掉</li></ul><p>根据入站和出站的不同，Netty将ChannelHandler扩展了两个重要的子类：</p><ul><li>ChannelInboundHandler：负责处理入站的数据以及各种状态变化</li><li>ChannelOutboundHandler：负责处理出站的数据并且允许拦截所有的数据</li></ul><p>ChannelHandler和ChannelPipeline的关系如下图所示：</p><p><img src="/images/netty_channle_pipeline_in_out.png" alt="netty_channle_pipeline_in_out.png"></p><h3 id="什么是ChannelHandlerContext？"><a href="#什么是ChannelHandlerContext？" class="headerlink" title="什么是ChannelHandlerContext？"></a>什么是ChannelHandlerContext？</h3><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。</p><p>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 ChannelPipeline 本身上，但是有一点重要的不同。如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。 而调用位于 ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler。</p><p>值得注意的是：</p><ul><li><p>ChannelHandlerContext 和 ChannelHandler 之间的关联(绑定)是永远不会改变的，所以缓存对它的引用是安全的;</p></li><li><p>如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</p></li></ul><p>Channel，ChannelPipeline，ChannelHandler和ChannelHandlerContext四者之间的关系如下：</p><p><img src="/images/netty_channel_handler_process.png" alt="netty_channel_handler_process.png"></p><p>ChannelHandler，ChannelPipeline和ChannelHandlerContext三者的对应关系如下：</p><p><img src="/images/netty_handler_context_pipeline_relation.png" alt="netty_handler_context_pipeline_relation.png"></p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是ChannelPipeline？&quot;&gt;&lt;a href=&quot;#什么是ChannelPipeline？&quot; class=&quot;headerlink&quot; title=&quot;什么是ChannelPipeline？&quot;&gt;&lt;/a&gt;什么是ChannelPipeline？&lt;/h3&gt;&lt;p&gt;抽象</summary>
      
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>Netty-Channel</title>
    <link href="http://example.com/2020/10/21/netty-channel/"/>
    <id>http://example.com/2020/10/21/netty-channel/</id>
    <published>2020-10-21T11:55:43.000Z</published>
    <updated>2021-08-26T12:23:36.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Channel"><a href="#什么是Channel" class="headerlink" title="什么是Channel"></a>什么是Channel</h3><p>Channel（当然是Netty自己抽象的Channel）是netty的网络操作对象，也可以这么说，Channel是与网络Socket套接字的联系。但是归根究底，Channel是一个用于I/O操作的组件，负责诸如：读，写，连接，绑定等操作。</p><h3 id="Channel能做写什么事情"><a href="#Channel能做写什么事情" class="headerlink" title="Channel能做写什么事情"></a>Channel能做写什么事情</h3><p>Channel为用户提供了：</p><ul><li>Channel的当前状态（例如，是否打开？是否已连接？）</li><li>Channel的ChannelConfig配置参数（例如，接收缓冲区的大小）</li><li>通道支持的I / O操作（例如，读，写，连接和绑定）</li><li>ChannelPipeline处理所有与该通道相关的I/O事件和请求</li></ul><h3 id="Channel的工作原理"><a href="#Channel的工作原理" class="headerlink" title="Channel的工作原理"></a>Channel的工作原理</h3><h3 id="Channel的功能介绍"><a href="#Channel的功能介绍" class="headerlink" title="Channel的功能介绍"></a>Channel的功能介绍</h3><p>我们接下来就来了解一下Channel大概涵盖了那些功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelId id();</span><br></pre></td></tr></table></figure><p>返回的是一个ChannelId对象，通过调用ChannelId相关的方法，获取到的是字符串类型的Id，这个Id代表了当前这个Channel通道，是Channel的唯一标识，可以理解为是一个key。他的可能生成策略如下：</p><ol><li>机器的MAC地址等可以代表全局唯一的信息；</li><li>当前的进程ID；</li><li>当前系统的毫秒/纳秒；</li><li>32位的随机整型数；</li><li>32位自增的序列数；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventLoop eventLoop();</span><br></pre></td></tr></table></figure><p>这个方法返回的是EventLoop.Channel需要注册到多路复用器上，用于处理I/O事件，通过此方法可以获取到当前Channel注册的EventLoop。EventLoop本质上就是处理网络读写的Reactor线程。在Netty中，它不单单只是用于处理网络事件，也可以用来执行定时任务和用户自定义的NioTask等任务。（具体可以阅读EventLoop的相关博客内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel parent();</span><br></pre></td></tr></table></figure><p>对于服务端的Channel来说，它的父Channel为null。对于客户端来说，它的parent就是创建它的ServerSocketChannel。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelConfig config();</span><br></pre></td></tr></table></figure><p>获取当前Channel的配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpen();</span><br></pre></td></tr></table></figure><p>用于判断当前Channel是否已经打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isRegistered();</span><br></pre></td></tr></table></figure><p>判断当前Channel是否已经注册到EventLoop上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isActive();</span><br></pre></td></tr></table></figure><p>判断当前channel是否处于激活状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress localAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel绑定的本地地址，若当前channel未绑定，则返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress remoteAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel连接的远端地址，若当前Channel没有被连接，则返回null。</p><p>以上是一些Channel的一些方法的定义，由于本身Channel是一个抽象的接口，所以Channel里面只有方法的定义而没有涉及到一些具体的操作，详情还是要结合源码来一起分析Channel的。</p><h3 id="Channel源码分析"><a href="#Channel源码分析" class="headerlink" title="Channel源码分析"></a>Channel源码分析</h3><p>由于Channel是一个顶层接口，其实现类非常的多，如果读者有兴趣想进一步了解的，可以从官网上下载其源码进行分析Channel到底有哪些实现类，以及这些实现类到底能做些什么事情。这里我们就主要分析其两个比较主要的实现类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="Channel继承关系类图"><a href="#Channel继承关系类图" class="headerlink" title="Channel继承关系类图"></a>Channel继承关系类图</h4><p>首先看 NioServerSocketChannel 的继承关系类图：</p><p><img src="/images/netty_channel_class_extends.png" alt="netty_channel_class_extends.png"></p><p>其次是 NioSocketChannel 的继承关系类图：</p><p><img src="/images/netty_nio_socket_channel.png" alt="netty_nio_socket_channel.png"></p><p>刨除Channel顶层接口实现的几个接口以及AbstractChannel抽象类继承的抽象类之外，NioServerSocketChannel 和 NioSocketChannel的继承关系还是相对简单的。</p><p>下面我们就来具体的分析。</p><h4 id="AbstractChannel的源码分析"><a href="#AbstractChannel的源码分析" class="headerlink" title="AbstractChannel的源码分析"></a>AbstractChannel的源码分析</h4><h5 id="成员变量的定义"><a href="#成员变量的定义" class="headerlink" title="成员变量的定义"></a>成员变量的定义</h5><p>先来看一下AbstractChannel成员变量的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final Channel parent;&#x2F;&#x2F; 父Channel</span><br><span class="line">private final ChannelId id;&#x2F;&#x2F; Channel全局唯一的ID</span><br><span class="line">private final Unsafe unsafe;&#x2F;&#x2F; Unsafe实例</span><br><span class="line">private final DefaultChannelPipeline pipeline;&#x2F;&#x2F; 当前Channel对应的PipeLine</span><br><span class="line">private volatile SocketAddress localAddress;</span><br><span class="line">private volatile SocketAddress remoteAddress;</span><br><span class="line">private volatile EventLoop eventLoop;</span><br><span class="line">private volatile boolean registered;</span><br><span class="line">private boolean closeInitiated;</span><br><span class="line">private Throwable initialCloseCause;</span><br><span class="line">private boolean strValActive;</span><br><span class="line">private String strVal;</span><br></pre></td></tr></table></figure><p>结合前面Channel的功能介绍，不难发现，这里面定义的一些个成员变量基本都是围绕着Channel的功能展开的，聚合了所有Channel使用到的能力对象，由AbstractChannel提供初始化和统一的封装，对于一些与子类强相关的方法则一抽象的形式去定义，由子类自己去具体实现。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractChannel(Channel parent) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       id &#x3D; newId();</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">protected AbstractChannel(Channel parent, ChannelId id) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="核心API的分析"><a href="#核心API的分析" class="headerlink" title="核心API的分析"></a>核心API的分析</h5><p>在Channel进行I/O操作的时候，他会触发对应的事件方法。Netty基于事件驱动，所以也就是说当Channel进行I/O操作的时候会产生响应的I/O事件，然后事件在PipeLine里面传播，然后由对应的ChannelHandler对事件进行拦截处理，有点类似于AOP。<br>大体看一下AbstractChannel的基本I/O操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture close(ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.close(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Channel read() &#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture write(Object msg) &#123;</span><br><span class="line">    return pipeline.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面图不难看出AbstractChannel的一些I/O操作也都是调用了DefaultChannelPipeline的方法来进行I/O的操作的，那也就是可以这么理解，AbstractChannel最最主要的作用就是对Channel一些功能点的初始化，其中最重要的是对DefaultChannelPipeline的初始化操作，因为AbstractChannel后续的I/O操作也都是调用它的方法来实现的，至此，AbstractChannel的源码我们也基本有了一定的了解。</p><p>下面我们再来看看在类图中AbstractChannel的下一级子类的源码。</p><h4 id="AbstractNioChannel源码分析"><a href="#AbstractNioChannel源码分析" class="headerlink" title="AbstractNioChannel源码分析"></a>AbstractNioChannel源码分析</h4><h5 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h5><p>老规矩，先从成员变量来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line">&#x2F;&#x2F; 代表JDK SelectionKey的OP_READ</span><br><span class="line">protected final int readInterestOp;</span><br><span class="line">volatile SelectionKey selectionKey;- </span><br><span class="line">boolean readPending;</span><br><span class="line">&#x2F;&#x2F; 连接操作结果</span><br><span class="line">private ChannelPromise connectPromise;</span><br><span class="line">&#x2F;&#x2F; 连接超时定时器</span><br><span class="line">private ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br><span class="line">&#x2F;&#x2F; 请求通讯地址</span><br><span class="line">private SocketAddress requestedRemoteAddress;</span><br></pre></td></tr></table></figure><p>第一个参数：这里定义了一个SelectableChannel，由于NIO Channel，NioSocketChannel和NioServerSocketChannel需要共用，所以定义了一个JDK NIO的SocketChannel和ServerSocketChannel的公共父类SelectableChannel用于设置SelectableChannel参数和进行I/O操作。</p><p>第二个参数：readInterestOp，如注解所示，这代表了JDK SelectionKey的OP_READ。</p><p>第三个参数：一个由Volatile修饰的selectionKey，这个key是Channel注册到EventLoop（Selector）之后返回的一个代表了这个Channel的key，通过这个key可以获取到对应的Channel，也代表了当前的Channel是处于什么操作：</p><ul><li>OP_ACCEPT：有新的网络连接可以 accept，值为 16</li><li>OP_CONNECT：代表连接已经建立，值为 8</li><li>OP_READ：代表读操作，值为 1</li><li>OP_WRITE：代表写操作，值为 4</li></ul><p>由于Channel会面临多个业务线程并发的写操作，所以使用volatile来让其他线程及时感知到当前Channel的状态。</p><h5 id="核心API源码分析"><a href="#核心API源码分析" class="headerlink" title="核心API源码分析"></a>核心API源码分析</h5><p>首先是同于Channel注册的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doRegister() throws Exception &#123;</span><br><span class="line">        boolean selected &#x3D; false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">                 if (!selected) &#123;</span><br><span class="line">    eventLoop().selectNow();</span><br><span class="line">                    selected &#x3D; true;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br></pre></td></tr></table></figure><p>其中方法javaChannel（）返回的其实就是在它成员变量里面定义了的SelectableChannel。SelectableChannel是JDK的NIO自带的通道视图。<br>看到这其实可以看出，底层的Netty其实还是调用了JDk的NIO来实现的。在register方法中的eventLoop（）方法返回的是其父类的成员变量定义的eventLoop，是一个NioEventLoop，然后获取其成员变量中定义的Selector多路复用器。在传入register注册方法里面的ops是0，则说明这里的注册对仍和I/O操作事件都不感兴趣，这里只是简单的将当前的Channel注册进Selector中。如果注册成功，则返回selectionKey，通过selectionKey可以从Selector中获取Channel对象。（SelectionKey是绑定Selector和Channel的中间纽带，之间是一对一的关系）<br>如果当前注册返回的selectionKey已经被取消，则抛出CancelledKeyException异常，捕获该异常进行处理。如果第一次处理该异常，调用多路复用器的selectNow（）方法将已经取消的selectionKey从多路复用器中删除。操作成功之后，将selected置为true，说明之前失效的selectionkey已经被删除。 继续发起下一轮注册操作，如果成功则退出，如果仍然发生CancelledKeyException异常，说明我们无法删除已经被取消的selectionkey，按理由这种操作不该发生，所以直接抛出异常到上层，由其自行处理。</p><p>接下来是另一个方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doBeginRead() throws Exception &#123;</span><br><span class="line">       final SelectionKey selectionKey &#x3D; this.selectionKey;</span><br><span class="line">       if (!selectionKey.isValid()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       readPending &#x3D; true;</span><br><span class="line">       final int interestOps &#x3D; selectionKey.interestOps();</span><br><span class="line">       if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在准备读取数据的时候需要先设置网络操作位为读，设置完之后才可以监听读事件。</p><p>至此AbstractNioChannel的源码基本就阅读完毕了，根据上面的分析，基本可以这么理解，AbstractNioChannel的作用是将当前的Channel通过NioEventLoop绑定到Selector多路复用器上面，这里是一个注册的作用。</p><p>下面我们继续往下看类图的下一部分AbstractNioByteChannel：</p><h4 id="AbstractNioByteChannel源码分析"><a href="#AbstractNioByteChannel源码分析" class="headerlink" title="AbstractNioByteChannel源码分析"></a>AbstractNioByteChannel源码分析</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable flushTask &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; Calling flush0 directly to ensure we not try to flush messages that were added via write(...) in the</span><br><span class="line">            &#x2F;&#x2F; meantime.</span><br><span class="line">            ((AbstractNioUnsafe) unsafe()).flush0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>AbstractNioByteChannel的成员变量就是一个Runnable类型的flushTask，负责继续写半包消息。</p><h5 id="API源码分析"><a href="#API源码分析" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这一块比较主要的方法是doWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">       do &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               clearOpWrite();</span><br><span class="line">               &#x2F;&#x2F; Directly return here so incompleteWrite(...) is not called.</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           writeSpinCount -&#x3D; doWriteInternal(in, msg);</span><br><span class="line">       &#125; while (writeSpinCount &gt; 0);&#x2F;&#x2F; 发送的消息不为空则继续doWriteInternal</span><br><span class="line">       incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上至下，首先通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount();</span><br></pre></td></tr></table></figure><p>获取此次写总共需要执行的循环次数。【循环次数是指一次发送没有完成（写半包），继续循环发送的次数】<br>然后从传递的参数ChannelOutboundBuffer调用current（）方法弹出一条消息，判断消息是否是null，如果是null，则说明消息发送数组里面所有等待发送的消息都发送完毕，清除写半包标记，结束循环。来看一下是如何清除写半包标识的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final void clearOpWrite() &#123;</span><br><span class="line">        final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final int interestOps &#x3D; key.interestOps();</span><br><span class="line">        if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">            key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从当前Selectionkey中获取网络操作位，然后与selectionkey.OP_WRITE做按位与，如果不等于0，说明当前的selectionkey是iswritable的，需要清除写操作位。 清除方法很简单，就是selectionkey.op_write取非之后与愿操作位按位与操作，清除selectionkey的写操作位。</p><p>再来看一下这边的循环次数是如何获取的，先看doWriteInternal代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      if (msg instanceof ByteBuf) &#123;</span><br><span class="line">          ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">          if (!buf.isReadable()) &#123;</span><br><span class="line">              in.remove();</span><br><span class="line">              return 0;</span><br><span class="line">          &#125;</span><br><span class="line">          final int localFlushedAmount &#x3D; doWriteBytes(buf);</span><br><span class="line">          if (localFlushedAmount &gt; 0) &#123;</span><br><span class="line">in.progress(localFlushedAmount);</span><br><span class="line">if (!buf.isReadable()) &#123;</span><br><span class="line">                  in.remove();</span><br><span class="line">              &#125;</span><br><span class="line">              return 1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里是有两部分的，一部分是对普通ByteBuf的逻辑，还有一部分是对FileRegion的判断，这里主要是ByteBuf。<br>首先，判断的当然是当前消息的类型是否是ByteBuf类型，如果是，则进行强转，然后判断当前的小时是否是可读的，若消息不可读，则直接从发送环形数组中删除当前消息，继续循环其他的消息。<br>然后继续向下走，判断消息可读，然后将当前buf的数据写入底层Chnannel，返回的是发送总数，所以这里的localFlushedAmount是指本次发送的字节数。我们来看看这个doWriteBytes底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected int doWriteBytes(ByteBuf buf) throws Exception &#123;</span><br><span class="line">        final int expectedWrittenBytes &#x3D; buf.readableBytes();</span><br><span class="line">        return buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难发现，其实际是将buf中可读的字节都写出到了目标Channel中。<br>回到doWriteInternal方法，我们就不用疑惑是否会出现localFlushedAmount大于0（也代表了写出了数据），然后buf还是可读的这种情况的出现了。在写出完毕之后，会调用ChannelOutboundBuffer更新发送进度信息。然后接着判断当前消息是否可读，不可读便从当前环形数组将当前消息删除。</p><p>至此，我们的doWrite方法已经快接近尾声了，循环部分已经分析完毕了，我么接着来看最后一个方法–incompleteWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line"></span><br><span class="line">protected final void incompleteWrite(boolean setOpWrite) &#123;</span><br><span class="line">       if (setOpWrite) &#123;         </span><br><span class="line">           setOpWrite();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">    clearOpWrite();</span><br><span class="line">           eventLoop().execute(flushTask);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里在调用incompleteWrite方法时候传入了循环次数来与0进行比较，如果循环次数不是小于0的，说明之前还有消息没有写完，因为循环没有结束嘛，所以当前如果消息没有写完，则调用setOpWrite（）方法去重新为当前Channel的SelectionKey设置写操作位。（注意⚠️：当SelectionKey的OP_WRITE的操作位被设置，那么当前Channel对应的Selector多路复用器就会不断的轮询对应的Channel用于处理没有处理完的半包消息，直到写操作位被清除为止。）<br>如果没有设置写操作位，那么就需要启用一个单独的Runnable，将其加入到EventLoop之中，由Runnable来负责处理写半包消息，他的实现也很简单，就是调用了flush（）来发送缓冲区的消息。</p><p>好了，AbstractBioByteChannel的源码到此就分析的差不多了。</p><p>下面就接着来分析NioServerSocketChannel的父类 – AbstractNioMessageChannel</p><h4 id="AbstractNioMessageChannel的源码分析"><a href="#AbstractNioMessageChannel的源码分析" class="headerlink" title="AbstractNioMessageChannel的源码分析"></a>AbstractNioMessageChannel的源码分析</h4><p>由于这个类没有成员变量，我们就直接跳到API源码分析。</p><h5 id="API源码分析-1"><a href="#API源码分析-1" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这里主要实现方法是doWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">       final int interestOps &#x3D; key.interestOps();</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">                   key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               boolean done &#x3D; false;</span><br><span class="line">               for (int i &#x3D; config().getWriteSpinCount() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                   if (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                       done &#x3D; true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (done) &#123;</span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F; Did not write all messages.</span><br><span class="line">                   if ((interestOps &amp; SelectionKey.OP_WRITE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                       key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (continueOnWriteError()) &#123;</span><br><span class="line">                   in.remove(e);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   throw e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>嗯姆。。。不对，等等！！！这代码好像在哪见过！没错，这里的代码和前面分析的AbstractNioByteChannel的doWrite方法几乎一模一样，AbstractNioByteChannel的doWrite多了一些封装，而这里写的比较直白一些。</p><p>如果仔细看，并且你还记得之前的AbstractNioByteChannel的大概的实现方式，你会发现，这里的doWriteMessage发送的是一个直接的pojo，而AbstractNioByteChannel发送的是ByteBuf或者FileRegion，还有就是，这里的处理半包的方式只采用了Selector多路复用器对对应的带有写操作位的Channel的轮询操作来处理未发送完的半包消息的。</p><p>接下来我们将会分析在类图最下面的两个类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="NioServerSocketChannel源码分析"><a href="#NioServerSocketChannel源码分析" class="headerlink" title="NioServerSocketChannel源码分析"></a>NioServerSocketChannel源码分析</h4><p>这部分的源码比较简单，先来看一下它的成员变量和静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final ChannelMetadata METADATA &#x3D; new ChannelMetadata(false, 16);</span><br><span class="line">private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER &#x3D; SelectorProvider.provider();</span><br><span class="line">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">   return provider.openServerSocketChannel();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          throw new ChannelException(</span><br><span class="line">                  &quot;Failed to open a server socket.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> private final ServerSocketChannelConfig config;</span><br></pre></td></tr></table></figure><p>首先是定义了一个ChannelMetadata用于存储元信息，然后是定义了一个SelectorProvider，然后用这个provider来打开通道。<br>最后是一个ServerSocketChannelConfig用来配置TCP参数。</p><p>来看一下NioServerSocketChannel的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannel() &#123;</span><br><span class="line">    this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(SelectorProvider provider) &#123;</span><br><span class="line">    this(newSocket(provider));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config &#x3D; new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仅有的三个构造函数之中，除了最后一个由调用者传递的ServerSocketChannel之外，其余两个构造函数都会在初始化的时候调用前面定义好的newSocket方法来生成一个ServerSocketChannel，而这个ServerSocketChannel是JDK NIO的Channel，然后调用到最后一个重载构造函数实现。最后你会发现，这里参数的传递到了AbstractNioChannel的构造函数中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.ch &#x3D; ch;</span><br><span class="line">        this.readInterestOp &#x3D; readInterestOp;</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.configureBlocking(false);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; catch (IOException e2) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Failed to close a partially initialized socket.&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 Channel 的 doReadMessages ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</span><br><span class="line">    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());</span><br><span class="line">    try &#123;</span><br><span class="line">        if (ch !&#x3D; null) &#123;</span><br><span class="line">            buf.add(new NioSocketChannel(this, ch));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t);</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (Throwable t2) &#123;</span><br><span class="line">            logger.warn(&quot;Failed to close a socket.&quot;, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过Netty的SocketUtils工具类接受客户端的连接，看一下传入的JavaChannel（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected ServerSocketChannel javaChannel() &#123;</span><br><span class="line">        return (ServerSocketChannel) super.javaChannel();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>往下走，会来到AbstractNioChannel ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line"></span><br><span class="line">protected SelectableChannel javaChannel() &#123;</span><br><span class="line">        return ch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不多分析这里的SelectableChannel，接着分析doReadMessages。<br>在接受了新的客户端连接之后，首先判断创建的连接是否是空，若不是空连接，则利用当前的NioServerSocketChannel和SocketChannel来创建一个新的NioSocketChannel，并将其加入List<Object> buf中，返回1，代表读取连接数据成功。<br>对于NioServerSocketChannel的读取操作就是接受客户端的连接，创建NioSocketChannel。</p><p>对于一些NioServerSocketChannel无需调用的方法，作者直接是返回了UnsupportedOperationException的异常来提示。</p><p>至此NioServerSocketChannel就分析完毕了，记住最重要的一点，NioServerSocketChannel的最要作用就是接受连接，创建NioSocketChannel。</p><p>接下来，我们来分析一下NioSocketChannel的实现。</p><h4 id="NioSocketChannel源码分析"><a href="#NioSocketChannel源码分析" class="headerlink" title="NioSocketChannel源码分析"></a>NioSocketChannel源码分析</h4><h5 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h5><p>重点分析与客户端连接有关的方法，首先来看连接 doConnect()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">        if (localAddress !&#x3D; null) &#123;</span><br><span class="line">            doBind0(localAddress);</span><br><span class="line">        &#125;</span><br><span class="line">         boolean success &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">    boolean connected &#x3D; </span><br><span class="line">                     SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">            if (!connected) &#123;</span><br><span class="line"> selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">            &#125;</span><br><span class="line">            success &#x3D; true;</span><br><span class="line">            return connected;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                doClose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断本地socket地址是否存在，若不为空，则调用doBind0方法去绑定本地Socket地址。<br>然后发起TCP连接远端Socket地址，若连接成功，则返回true，连接失败，则直接抛出I/O异常，若暂时没有连接上，不知道具体状态，则返回false。<br>若没有连接成功（不是失败），则重置Channel的SelectionKey的操作位为连接操作位。若是在连接的时候抛出了I/O异常，则success参数就为false，调用doClose（）关闭连接。</p><h5 id="写半包"><a href="#写半包" class="headerlink" title="写半包"></a>写半包</h5><p>先看一下源码的写半包的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">        SocketChannel ch &#x3D; javaChannel();</span><br><span class="line">        int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">        do &#123;</span><br><span class="line">            if (in.isEmpty()) &#123;</span><br><span class="line">                clearOpWrite();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">            ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br><span class="line">            int nioBufferCnt &#x3D; in.nioBufferCount();</span><br><span class="line"></span><br><span class="line">            switch (nioBufferCnt) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    writeSpinCount -&#x3D; doWrite0(in);</span><br><span class="line">                    break;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    ByteBuffer buffer &#x3D; nioBuffers[0];</span><br><span class="line">                    int attemptedBytes &#x3D; buffer.remaining();</span><br><span class="line">                    final int localWrittenBytes &#x3D; ch.write(buffer);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    long attemptedBytes &#x3D; in.nioBufferSize();</span><br><span class="line">                    final long localWrittenBytes &#x3D; ch.write(nioBuffers, 0, nioBufferCnt);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite((int) attemptedBytes, (int) localWrittenBytes,</span><br><span class="line">                            maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (writeSpinCount &gt; 0);</span><br><span class="line">        incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实在太多了，这一部分的处理也是比较复杂的，但是别急，都是写方法，如果你对于之前的源码分析都掌握了的话，其实这部分的源码也是换汤不换药的。<br>定义的SocketChannel基本都是从一个统一的方法javaChannel（）里面获取的。<br>既然要读，那首先我们就得知道这个数据我们得读多少次能读完，代码的体现就是通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount()</span><br></pre></td></tr></table></figure><p>来获取循环次数。这个是定义在ChannelConfig里面的，默认循环次数是16，取决于JVM运行的平台。<br>来到循环体里面，如果buf是空的，则清除写操作位，并return；<br>若不是空的，则继续向下走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br></pre></td></tr></table></figure><p>获取设置的单个ByteBuf的最大字节数，也就是设定了每个ByteBuf允许存储的最大字节的数量，获得了ByteBuf的最大字节数之后紧接着就是获取ByteBuf数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br></pre></td></tr></table></figure><p>通过ChannelOutboundBuffer获取ByteBuf数组，其中传递的参数是设置好的单个ByteBuf的最大字节数，以及允许的最大缓冲区数量，然后返回ByteBuf数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nioBufferCnt &#x3D; in.nioBufferCount();</span><br></pre></td></tr></table></figure><p>调用了buf的nioBufferCount（）方法，来获取需要发送的ByteBuffer数组个数。nioBufferCount（）方法必须在调用了nioBuffers（）之后才可以调用。</p><p>进入条件语句之后，若需要发送的ByteBuffer为0，则说明无消息需要发送，但是可能会有别的事情需要处理，所以调用了doWrite0，并将自旋减去其返回的数值。<br>当需要发送的ByteBuffer个数为1，则直接取数组内的第一个ByteBuffer去发送，然后是获取缓冲区剩余的可写字节数赋值给attemptedBytes。在调用了SocketChannel的write（）方法之后，方法会返回写入SocketChannel的字节数，判断写入的字节数，小于等于0说明TCP缓冲区已经满了，很肯能无法在继续写入，因此从循环中挑出，同时调用incompleteWrite（true）将写半包标识设置为true，用于向多路复用器注册写操作位，告诉多路复用器有没有发送完的半包消息，需要轮训出就绪的SocketChannel继续发送。<br>在处理完这些事情之后，ChannelOutbountBuffer的该部分缓冲区已经使用完毕了，于是会调用ChannelOutboundBuffer的清除方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in.removeBytes(localWrittenBytes);</span><br></pre></td></tr></table></figure><p>参数是之前写入SocketChannel的字节数。来看一下他的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void removeBytes(long writtenBytes) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        Object msg &#x3D; current();</span><br><span class="line">        if (!(msg instanceof ByteBuf)) &#123;</span><br><span class="line">            assert writtenBytes &#x3D;&#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        final ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        final int readerIndex &#x3D; buf.readerIndex();</span><br><span class="line">        final int readableBytes &#x3D; buf.writerIndex() - readerIndex;</span><br><span class="line">        if (readableBytes &lt;&#x3D; writtenBytes) &#123;</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                progress(readableBytes);</span><br><span class="line">                writtenBytes -&#x3D; readableBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            remove();</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; readableBytes &gt; writtenBytes</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                buf.readerIndex(readerIndex + (int) writtenBytes);</span><br><span class="line">                progress(writtenBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       clearNioBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，首先是从当前ChannelOutBoundBuffer弹出第一条发送的ByteBuf，然后获取读索引和可读字节数（可读字节数 = 写索引 - 读索引），<br>将可读字节数与已经发送的字节数进行比较，可读字节数小于等于已发送字节数说明当前的bytebuf已经完全被发送出去了，那么就更新ChannelOutboundBuffer的发送进度信息以及将写指针前移，然后清空该部分内存空间。若可读字节数大于已写出字节数，说明出现了半包问题，那就需要更新可读索引，将将读索引后移writtenBytes个位置，这样当下次轮询到的时候就会重新从正确的读索引处重新开始读取消息，然后也是更新ChannelOutboundBuffer的发送进度信息。</p><p>好了，Channel的部分源码解读到这就差不多了，由于篇幅限制，Channel的Unsafe就不再这里继续展开了，笔者会另开一章来专门介绍Unsafe的源码，敬请期待吧。</p><p>谢谢阅读。</p><p>本人关于图片作品版权的声明：</p><ol><li><p>本人在此刊载的原创作品，其版权归属本人所有。</p></li><li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p></li><li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p></li><li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p></li></ol><p>特此声明，敬请合作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Channel&quot;&gt;&lt;a href=&quot;#什么是Channel&quot; class=&quot;headerlink&quot; title=&quot;什么是Channel&quot;&gt;&lt;/a&gt;什么是Channel&lt;/h3&gt;&lt;p&gt;Channel（当然是Netty自己抽象的Channel）是netty的网络</summary>
      
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
  </entry>
  
</feed>
