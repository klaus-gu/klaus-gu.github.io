<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进学致和，行方思远。</title>
  
  <subtitle>人不过是一根芦苇,是自然界最脆弱的东西,但人却是一根能思考的芦苇。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-01T12:54:54.539Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>klaus_turbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty 之 Channel</title>
    <link href="http://example.com/2021/03/15/%C2%B6%C2%A4%C2%B6%C2%A4O%CC%88%C3%90A%CC%80%C2%B9%C2%BD%C3%98%C3%97o%CC%81%C2%B2a%CC%80%C2%B7%C2%B5%C2%BB%C3%98%C2%BCu%CC%88/"/>
    <id>http://example.com/2021/03/15/%C2%B6%C2%A4%C2%B6%C2%A4O%CC%88%C3%90A%CC%80%C2%B9%C2%BD%C3%98%C3%97o%CC%81%C2%B2a%CC%80%C2%B7%C2%B5%C2%BB%C3%98%C2%BCu%CC%88/</id>
    <published>2021-03-15T09:04:18.000Z</published>
    <updated>2021-07-01T12:54:54.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Channel"><a href="#什么是Channel" class="headerlink" title="什么是Channel"></a>什么是Channel</h3><p>Channel（当然是Netty自己抽象的Channel）是netty的网络操作对象，也可以这么说，Channel是与网络Socket套接字的联系。但是归根究底，Channel是一个用于I/O操作的组件，负责诸如：读，写，连接，绑定等操作。</p><h3 id="Channel能做写什么事情"><a href="#Channel能做写什么事情" class="headerlink" title="Channel能做写什么事情"></a>Channel能做写什么事情</h3><p>Channel为用户提供了：</p><ul><li>Channel的当前状态（例如，是否打开？是否已连接？）</li><li>Channel的ChannelConfig配置参数（例如，接收缓冲区的大小）</li><li>通道支持的I / O操作（例如，读，写，连接和绑定）</li><li>ChannelPipeline处理所有与该通道相关的I/O事件和请求</li></ul><h3 id="Channel的工作原理"><a href="#Channel的工作原理" class="headerlink" title="Channel的工作原理"></a>Channel的工作原理</h3><h3 id="Channel的功能介绍"><a href="#Channel的功能介绍" class="headerlink" title="Channel的功能介绍"></a>Channel的功能介绍</h3><p>我们接下来就来了解一下Channel大概涵盖了那些功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelId id();</span><br></pre></td></tr></table></figure><p>返回的是一个ChannelId对象，通过调用ChannelId相关的方法，获取到的是字符串类型的Id，这个Id代表了当前这个Channel通道，是Channel的唯一标识，可以理解为是一个key。他的可能生成策略如下：</p><ol><li>机器的MAC地址等可以代表全局唯一的信息；</li><li>当前的进程ID；</li><li>当前系统的毫秒/纳秒；</li><li>32位的随机整型数；</li><li>32位自增的序列数；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventLoop eventLoop();</span><br></pre></td></tr></table></figure><p>这个方法返回的是EventLoop.Channel需要注册到多路复用器上，用于处理I/O事件，通过此方法可以获取到当前Channel注册的EventLoop。EventLoop本质上就是处理网络读写的Reactor线程。在Netty中，它不单单只是用于处理网络事件，也可以用来执行定时任务和用户自定义的NioTask等任务。（具体可以阅读EventLoop的相关博客内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel parent();</span><br></pre></td></tr></table></figure><p>对于服务端的Channel来说，它的父Channel为null。对于客户端来说，它的parent就是创建它的ServerSocketChannel。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelConfig config();</span><br></pre></td></tr></table></figure><p>获取当前Channel的配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpen();</span><br></pre></td></tr></table></figure><p>用于判断当前Channel是否已经打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isRegistered();</span><br></pre></td></tr></table></figure><p>判断当前Channel是否已经注册到EventLoop上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isActive();</span><br></pre></td></tr></table></figure><p>判断当前channel是否处于激活状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress localAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel绑定的本地地址，若当前channel未绑定，则返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress remoteAddress();</span><br></pre></td></tr></table></figure><p>获取当前Channel连接的远端地址，若当前Channel没有被连接，则返回null。</p><p>以上是一些Channel的一些方法的定义，由于本身Channel是一个抽象的接口，所以Channel里面只有方法的定义而没有涉及到一些具体的操作，详情还是要结合源码来一起分析Channel的。</p><h3 id="Channel源码分析"><a href="#Channel源码分析" class="headerlink" title="Channel源码分析"></a>Channel源码分析</h3><p>由于Channel是一个顶层接口，其实现类非常的多，如果读者有兴趣想进一步了解的，可以从官网上下载其源码进行分析Channel到底有哪些实现类，以及这些实现类到底能做些什么事情。这里我们就主要分析其两个比较主要的实现类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="Channel继承关系类图"><a href="#Channel继承关系类图" class="headerlink" title="Channel继承关系类图"></a>Channel继承关系类图</h4><p>首先看++NioServerSocketChannel++的继承关系类图：</p><p><img src="http://139.196.124.206:8090/upload/2020/10/%E6%88%AA%E5%B1%8F2020-10-21%2020.45.15-05f75eef50a94e4fbd38e8ef78e34586.png" alt="截屏20201021 20.45.15.png"></p><p>其次是++NioSocketChannel++的继承关系类图：</p><p><img src="http://139.196.124.206:8090/upload/2020/10/%E6%88%AA%E5%B1%8F2020-10-21%2020.50.14-ebfd6806d0694d64a26d3b9fcf4fb944.png" alt="截屏20201021 20.50.14.png"></p><p>刨除Channel顶层接口实现的几个接口以及AbstractChannel抽象类继承的抽象类之外，NioServerSocketChannel 和 NioSocketChannel的继承关系还是相对简单的。</p><p>下面我们就来具体的分析。</p><h4 id="AbstractChannel的源码分析"><a href="#AbstractChannel的源码分析" class="headerlink" title="AbstractChannel的源码分析"></a>AbstractChannel的源码分析</h4><h5 id="成员变量的定义"><a href="#成员变量的定义" class="headerlink" title="成员变量的定义"></a>成员变量的定义</h5><p>先来看一下AbstractChannel成员变量的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final Channel parent;&#x2F;&#x2F; 父Channel</span><br><span class="line">private final ChannelId id;&#x2F;&#x2F; Channel全局唯一的ID</span><br><span class="line">private final Unsafe unsafe;&#x2F;&#x2F; Unsafe实例</span><br><span class="line">private final DefaultChannelPipeline pipeline;&#x2F;&#x2F; 当前Channel对应的PipeLine</span><br><span class="line">private volatile SocketAddress localAddress;</span><br><span class="line">private volatile SocketAddress remoteAddress;</span><br><span class="line">private volatile EventLoop eventLoop;</span><br><span class="line">private volatile boolean registered;</span><br><span class="line">private boolean closeInitiated;</span><br><span class="line">private Throwable initialCloseCause;</span><br><span class="line">private boolean strValActive;</span><br><span class="line">private String strVal;</span><br></pre></td></tr></table></figure><p>结合前面Channel的功能介绍，不难发现，这里面定义的一些个成员变量基本都是围绕着Channel的功能展开的，聚合了所有Channel使用到的能力对象，由AbstractChannel提供初始化和统一的封装，对于一些与子类强相关的方法则一抽象的形式去定义，由子类自己去具体实现。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractChannel(Channel parent) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       id &#x3D; newId();</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">protected AbstractChannel(Channel parent, ChannelId id) &#123;</span><br><span class="line">       this.parent &#x3D; parent;</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">       unsafe &#x3D; newUnsafe();</span><br><span class="line">       pipeline &#x3D; newChannelPipeline();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="核心API的分析"><a href="#核心API的分析" class="headerlink" title="核心API的分析"></a>核心API的分析</h5><p>在Channel进行I/O操作的时候，他会触发对应的事件方法。Netty基于事件驱动，所以也就是说当Channel进行I/O操作的时候会产生响应的I/O事件，然后事件在PipeLine里面传播，然后由对应的ChannelHandler对事件进行拦截处理，有点类似于AOP。<br>大体看一下AbstractChannel的基本I/O操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture close(ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.close(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Channel read() &#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelFuture write(Object msg) &#123;</span><br><span class="line">    return pipeline.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面图不难看出AbstractChannel的一些I/O操作也都是调用了DefaultChannelPipeline的方法来进行I/O的操作的，那也就是可以这么理解，AbstractChannel最最主要的作用就是对Channel一些功能点的初始化，其中最重要的是对DefaultChannelPipeline的初始化操作，因为AbstractChannel后续的I/O操作也都是调用它的方法来实现的，至此，AbstractChannel的源码我们也基本有了一定的了解。</p><p>下面我们再来看看在类图中AbstractChannel的下一级子类的源码。</p><h4 id="AbstractNioChannel源码分析"><a href="#AbstractNioChannel源码分析" class="headerlink" title="AbstractNioChannel源码分析"></a>AbstractNioChannel源码分析</h4><h5 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h5><p>老规矩，先从成员变量来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line">&#x2F;&#x2F; 代表JDK SelectionKey的OP_READ</span><br><span class="line">protected final int readInterestOp;</span><br><span class="line">volatile SelectionKey selectionKey;- </span><br><span class="line">boolean readPending;</span><br><span class="line">&#x2F;&#x2F; 连接操作结果</span><br><span class="line">private ChannelPromise connectPromise;</span><br><span class="line">&#x2F;&#x2F; 连接超时定时器</span><br><span class="line">private ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br><span class="line">&#x2F;&#x2F; 请求通讯地址</span><br><span class="line">private SocketAddress requestedRemoteAddress;</span><br></pre></td></tr></table></figure><p>第一个参数：这里定义了一个SelectableChannel，由于NIO Channel，NioSocketChannel和NioServerSocketChannel需要共用，所以定义了一个JDK NIO的SocketChannel和ServerSocketChannel的公共父类SelectableChannel用于设置SelectableChannel参数和进行I/O操作。</p><p>第二个参数：readInterestOp，如注解所示，这代表了JDK SelectionKey的OP_READ。</p><p>第三个参数：一个由Volatile修饰的selectionKey，这个key是Channel注册到EventLoop（Selector）之后返回的一个代表了这个Channel的key，通过这个key可以获取到对应的Channel，也代表了当前的Channel是处于什么操作：</p><ul><li>OP_ACCEPT：有新的网络连接可以 accept，值为 16</li><li>OP_CONNECT：代表连接已经建立，值为 8</li><li>OP_READ：代表读操作，值为 1</li><li>OP_WRITE：代表写操作，值为 4</li></ul><p>由于Channel会面临多个业务线程并发的写操作，所以使用volatile来让其他线程及时感知到当前Channel的状态。</p><h5 id="核心API源码分析"><a href="#核心API源码分析" class="headerlink" title="核心API源码分析"></a>核心API源码分析</h5><p>首先是同于Channel注册的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doRegister() throws Exception &#123;</span><br><span class="line">        boolean selected &#x3D; false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">                 if (!selected) &#123;</span><br><span class="line">    eventLoop().selectNow();</span><br><span class="line">                    selected &#x3D; true;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey &#x3D;javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br></pre></td></tr></table></figure><p>其中方法javaChannel（）返回的其实就是在它成员变量里面定义了的SelectableChannel。SelectableChannel是JDK的NIO自带的通道视图。<br>看到这其实可以看出，底层的Netty其实还是调用了JDk的NIO来实现的。在register方法中的eventLoop（）方法返回的是其父类的成员变量定义的eventLoop，是一个NioEventLoop，然后获取其成员变量中定义的Selector多路复用器。在传入register注册方法里面的ops是0，则说明这里的注册对仍和I/O操作事件都不感兴趣，这里只是简单的将当前的Channel注册进Selector中。如果注册成功，则返回selectionKey，通过selectionKey可以从Selector中获取Channel对象。（SelectionKey是绑定Selector和Channel的中间纽带，之间是一对一的关系）<br>如果当前注册返回的selectionKey已经被取消，则抛出CancelledKeyException异常，捕获该异常进行处理。如果第一次处理该异常，调用多路复用器的selectNow（）方法将已经取消的selectionKey从多路复用器中删除。操作成功之后，将selected置为true，说明之前失效的selectionkey已经被删除。 继续发起下一轮注册操作，如果成功则退出，如果仍然发生CancelledKeyException异常，说明我们无法删除已经被取消的selectionkey，按理由这种操作不该发生，所以直接抛出异常到上层，由其自行处理。</p><p>接下来是另一个方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doBeginRead() throws Exception &#123;</span><br><span class="line">       final SelectionKey selectionKey &#x3D; this.selectionKey;</span><br><span class="line">       if (!selectionKey.isValid()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       readPending &#x3D; true;</span><br><span class="line">       final int interestOps &#x3D; selectionKey.interestOps();</span><br><span class="line">       if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在准备读取数据的时候需要先设置网络操作位为读，设置完之后才可以监听读事件。</p><p>至此AbstractNioChannel的源码基本就阅读完毕了，根据上面的分析，基本可以这么理解，AbstractNioChannel的作用是将当前的Channel通过NioEventLoop绑定到Selector多路复用器上面，这里是一个注册的作用。</p><p>下面我们继续往下看类图的下一部分AbstractNioByteChannel：</p><h4 id="AbstractNioByteChannel源码分析"><a href="#AbstractNioByteChannel源码分析" class="headerlink" title="AbstractNioByteChannel源码分析"></a>AbstractNioByteChannel源码分析</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable flushTask &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; Calling flush0 directly to ensure we not try to flush messages that were added via write(...) in the</span><br><span class="line">            &#x2F;&#x2F; meantime.</span><br><span class="line">            ((AbstractNioUnsafe) unsafe()).flush0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>AbstractNioByteChannel的成员变量就是一个Runnable类型的flushTask，负责继续写半包消息。</p><h5 id="API源码分析"><a href="#API源码分析" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这一块比较主要的方法是doWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">       do &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               clearOpWrite();</span><br><span class="line">               &#x2F;&#x2F; Directly return here so incompleteWrite(...) is not called.</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           writeSpinCount -&#x3D; doWriteInternal(in, msg);</span><br><span class="line">       &#125; while (writeSpinCount &gt; 0);&#x2F;&#x2F; 发送的消息不为空则继续doWriteInternal</span><br><span class="line">       incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上至下，首先通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount();</span><br></pre></td></tr></table></figure><p>获取此次写总共需要执行的循环次数。【循环次数是指一次发送没有完成（写半包），继续循环发送的次数】<br>然后从传递的参数ChannelOutboundBuffer调用current（）方法弹出一条消息，判断消息是否是null，如果是null，则说明消息发送数组里面所有等待发送的消息都发送完毕，清除写半包标记，结束循环。来看一下是如何清除写半包标识的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final void clearOpWrite() &#123;</span><br><span class="line">        final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final int interestOps &#x3D; key.interestOps();</span><br><span class="line">        if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">            key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从当前Selectionkey中获取网络操作位，然后与selectionkey.OP_WRITE做按位与，如果不等于0，说明当前的selectionkey是iswritable的，需要清除写操作位。 清除方法很简单，就是selectionkey.op_write取非之后与愿操作位按位与操作，清除selectionkey的写操作位。</p><p>再来看一下这边的循环次数是如何获取的，先看doWriteInternal代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      if (msg instanceof ByteBuf) &#123;</span><br><span class="line">          ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">          if (!buf.isReadable()) &#123;</span><br><span class="line">              in.remove();</span><br><span class="line">              return 0;</span><br><span class="line">          &#125;</span><br><span class="line">          final int localFlushedAmount &#x3D; doWriteBytes(buf);</span><br><span class="line">          if (localFlushedAmount &gt; 0) &#123;</span><br><span class="line">in.progress(localFlushedAmount);</span><br><span class="line">if (!buf.isReadable()) &#123;</span><br><span class="line">                  in.remove();</span><br><span class="line">              &#125;</span><br><span class="line">              return 1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里是有两部分的，一部分是对普通ByteBuf的逻辑，还有一部分是对FileRegion的判断，这里主要是ByteBuf。<br>首先，判断的当然是当前消息的类型是否是ByteBuf类型，如果是，则进行强转，然后判断当前的小时是否是可读的，若消息不可读，则直接从发送环形数组中删除当前消息，继续循环其他的消息。<br>然后继续向下走，判断消息可读，然后将当前buf的数据写入底层Chnannel，返回的是发送总数，所以这里的localFlushedAmount是指本次发送的字节数。我们来看看这个doWriteBytes底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected int doWriteBytes(ByteBuf buf) throws Exception &#123;</span><br><span class="line">        final int expectedWrittenBytes &#x3D; buf.readableBytes();</span><br><span class="line">        return buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难发现，其实际是将buf中可读的字节都写出到了目标Channel中。<br>回到doWriteInternal方法，我们就不用疑惑是否会出现localFlushedAmount大于0（也代表了写出了数据），然后buf还是可读的这种情况的出现了。在写出完毕之后，会调用ChannelOutboundBuffer更新发送进度信息。然后接着判断当前消息是否可读，不可读便从当前环形数组将当前消息删除。</p><p>至此，我们的doWrite方法已经快接近尾声了，循环部分已经分析完毕了，我么接着来看最后一个方法–incompleteWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line"></span><br><span class="line">protected final void incompleteWrite(boolean setOpWrite) &#123;</span><br><span class="line">       if (setOpWrite) &#123;         </span><br><span class="line">           setOpWrite();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">    clearOpWrite();</span><br><span class="line">           eventLoop().execute(flushTask);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里在调用incompleteWrite方法时候传入了循环次数来与0进行比较，如果循环次数不是小于0的，说明之前还有消息没有写完，因为循环没有结束嘛，所以当前如果消息没有写完，则调用setOpWrite（）方法去重新为当前Channel的SelectionKey设置写操作位。（注意⚠️：当SelectionKey的OP_WRITE的操作位被设置，那么当前Channel对应的Selector多路复用器就会不断的轮询对应的Channel用于处理没有处理完的半包消息，直到写操作位被清除为止。）<br>如果没有设置写操作位，那么就需要启用一个单独的Runnable，将其加入到EventLoop之中，由Runnable来负责处理写半包消息，他的实现也很简单，就是调用了flush（）来发送缓冲区的消息。</p><p>好了，AbstractBioByteChannel的源码到此就分析的差不多了。</p><p>下面就接着来分析NioServerSocketChannel的父类 – AbstractNioMessageChannel</p><h4 id="AbstractNioMessageChannel的源码分析"><a href="#AbstractNioMessageChannel的源码分析" class="headerlink" title="AbstractNioMessageChannel的源码分析"></a>AbstractNioMessageChannel的源码分析</h4><p>由于这个类没有成员变量，我们就直接跳到API源码分析。</p><h5 id="API源码分析-1"><a href="#API源码分析-1" class="headerlink" title="API源码分析"></a>API源码分析</h5><p>这里主要实现方法是doWrite（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">       final SelectionKey key &#x3D; selectionKey();</span><br><span class="line">       final int interestOps &#x3D; key.interestOps();</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Object msg &#x3D; in.current();</span><br><span class="line">           if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; Wrote all messages.</span><br><span class="line">               if ((interestOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">                   key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               boolean done &#x3D; false;</span><br><span class="line">               for (int i &#x3D; config().getWriteSpinCount() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                   if (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                       done &#x3D; true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (done) &#123;</span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F; Did not write all messages.</span><br><span class="line">                   if ((interestOps &amp; SelectionKey.OP_WRITE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                       key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (continueOnWriteError()) &#123;</span><br><span class="line">                   in.remove(e);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   throw e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>嗯姆。。。不对，等等！！！这代码好像在哪见过！没错，这里的代码和前面分析的AbstractNioByteChannel的doWrite方法几乎一模一样，AbstractNioByteChannel的doWrite多了一些封装，而这里写的比较直白一些。</p><p>如果仔细看，并且你还记得之前的AbstractNioByteChannel的大概的实现方式，你会发现，这里的doWriteMessage发送的是一个直接的pojo，而AbstractNioByteChannel发送的是ByteBuf或者FileRegion，还有就是，这里的处理半包的方式只采用了Selector多路复用器对对应的带有写操作位的Channel的轮询操作来处理未发送完的半包消息的。</p><p>接下来我们将会分析在类图最下面的两个类，NioServerSocketChannel和NioSocketChannel。</p><h4 id="NioServerSocketChannel源码分析"><a href="#NioServerSocketChannel源码分析" class="headerlink" title="NioServerSocketChannel源码分析"></a>NioServerSocketChannel源码分析</h4><p>这部分的源码比较简单，先来看一下它的成员变量和静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final ChannelMetadata METADATA &#x3D; new ChannelMetadata(false, 16);</span><br><span class="line">private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER &#x3D; SelectorProvider.provider();</span><br><span class="line">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">   return provider.openServerSocketChannel();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          throw new ChannelException(</span><br><span class="line">                  &quot;Failed to open a server socket.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> private final ServerSocketChannelConfig config;</span><br></pre></td></tr></table></figure><p>首先是定义了一个ChannelMetadata用于存储元信息，然后是定义了一个SelectorProvider，然后用这个provider来打开通道。<br>最后是一个ServerSocketChannelConfig用来配置TCP参数。</p><p>来看一下NioServerSocketChannel的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannel() &#123;</span><br><span class="line">    this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(SelectorProvider provider) &#123;</span><br><span class="line">    this(newSocket(provider));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config &#x3D; new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仅有的三个构造函数之中，除了最后一个由调用者传递的ServerSocketChannel之外，其余两个构造函数都会在初始化的时候调用前面定义好的newSocket方法来生成一个ServerSocketChannel，而这个ServerSocketChannel是JDK NIO的Channel，然后调用到最后一个重载构造函数实现。最后你会发现，这里参数的传递到了AbstractNioChannel的构造函数中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.ch &#x3D; ch;</span><br><span class="line">        this.readInterestOp &#x3D; readInterestOp;</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.configureBlocking(false);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; catch (IOException e2) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Failed to close a partially initialized socket.&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 Channel 的 doReadMessages ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</span><br><span class="line">    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());</span><br><span class="line">    try &#123;</span><br><span class="line">        if (ch !&#x3D; null) &#123;</span><br><span class="line">            buf.add(new NioSocketChannel(this, ch));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t);</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (Throwable t2) &#123;</span><br><span class="line">            logger.warn(&quot;Failed to close a socket.&quot;, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过Netty的SocketUtils工具类接受客户端的连接，看一下传入的JavaChannel（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected ServerSocketChannel javaChannel() &#123;</span><br><span class="line">        return (ServerSocketChannel) super.javaChannel();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>往下走，会来到AbstractNioChannel ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final SelectableChannel ch;</span><br><span class="line"></span><br><span class="line">protected SelectableChannel javaChannel() &#123;</span><br><span class="line">        return ch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不多分析这里的SelectableChannel，接着分析doReadMessages。<br>在接受了新的客户端连接之后，首先判断创建的连接是否是空，若不是空连接，则利用当前的NioServerSocketChannel和SocketChannel来创建一个新的NioSocketChannel，并将其加入List<Object> buf中，返回1，代表读取连接数据成功。<br>对于NioServerSocketChannel的读取操作就是接受客户端的连接，创建NioSocketChannel。</p><p>对于一些NioServerSocketChannel无需调用的方法，作者直接是返回了UnsupportedOperationException的异常来提示。</p><p>至此NioServerSocketChannel就分析完毕了，记住最重要的一点，NioServerSocketChannel的最要作用就是接受连接，创建NioSocketChannel。</p><p>接下来，我们来分析一下NioSocketChannel的实现。</p><h4 id="NioSocketChannel源码分析"><a href="#NioSocketChannel源码分析" class="headerlink" title="NioSocketChannel源码分析"></a>NioSocketChannel源码分析</h4><h5 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h5><p>重点分析与客户端连接有关的方法，首先来看连接 doConnect()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">        if (localAddress !&#x3D; null) &#123;</span><br><span class="line">            doBind0(localAddress);</span><br><span class="line">        &#125;</span><br><span class="line">         boolean success &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">    boolean connected &#x3D; </span><br><span class="line">                     SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">            if (!connected) &#123;</span><br><span class="line"> selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">            &#125;</span><br><span class="line">            success &#x3D; true;</span><br><span class="line">            return connected;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                doClose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断本地socket地址是否存在，若不为空，则调用doBind0方法去绑定本地Socket地址。<br>然后发起TCP连接远端Socket地址，若连接成功，则返回true，连接失败，则直接抛出I/O异常，若暂时没有连接上，不知道具体状态，则返回false。<br>若没有连接成功（不是失败），则重置Channel的SelectionKey的操作位为连接操作位。若是在连接的时候抛出了I/O异常，则success参数就为false，调用doClose（）关闭连接。</p><h5 id="写半包"><a href="#写半包" class="headerlink" title="写半包"></a>写半包</h5><p>先看一下源码的写半包的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">        SocketChannel ch &#x3D; javaChannel();</span><br><span class="line">        int writeSpinCount &#x3D; config().getWriteSpinCount();</span><br><span class="line">        do &#123;</span><br><span class="line">            if (in.isEmpty()) &#123;</span><br><span class="line">                clearOpWrite();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">            ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br><span class="line">            int nioBufferCnt &#x3D; in.nioBufferCount();</span><br><span class="line"></span><br><span class="line">            switch (nioBufferCnt) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    writeSpinCount -&#x3D; doWrite0(in);</span><br><span class="line">                    break;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    ByteBuffer buffer &#x3D; nioBuffers[0];</span><br><span class="line">                    int attemptedBytes &#x3D; buffer.remaining();</span><br><span class="line">                    final int localWrittenBytes &#x3D; ch.write(buffer);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    long attemptedBytes &#x3D; in.nioBufferSize();</span><br><span class="line">                    final long localWrittenBytes &#x3D; ch.write(nioBuffers, 0, nioBufferCnt);</span><br><span class="line">                    if (localWrittenBytes &lt;&#x3D; 0) &#123;</span><br><span class="line">                        incompleteWrite(true);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite((int) attemptedBytes, (int) localWrittenBytes,</span><br><span class="line">                            maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (writeSpinCount &gt; 0);</span><br><span class="line">        incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实在太多了，这一部分的处理也是比较复杂的，但是别急，都是写方法，如果你对于之前的源码分析都掌握了的话，其实这部分的源码也是换汤不换药的。<br>定义的SocketChannel基本都是从一个统一的方法javaChannel（）里面获取的。<br>既然要读，那首先我们就得知道这个数据我们得读多少次能读完，代码的体现就是通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().getWriteSpinCount()</span><br></pre></td></tr></table></figure><p>来获取循环次数。这个是定义在ChannelConfig里面的，默认循环次数是16，取决于JVM运行的平台。<br>来到循环体里面，如果buf是空的，则清除写操作位，并return；<br>若不是空的，则继续向下走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxBytesPerGatheringWrite &#x3D; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br></pre></td></tr></table></figure><p>获取设置的单个ByteBuf的最大字节数，也就是设定了每个ByteBuf允许存储的最大字节的数量，获得了ByteBuf的最大字节数之后紧接着就是获取ByteBuf数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] nioBuffers &#x3D; in.nioBuffers(1024, maxBytesPerGatheringWrite);</span><br></pre></td></tr></table></figure><p>通过ChannelOutboundBuffer获取ByteBuf数组，其中传递的参数是设置好的单个ByteBuf的最大字节数，以及允许的最大缓冲区数量，然后返回ByteBuf数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nioBufferCnt &#x3D; in.nioBufferCount();</span><br></pre></td></tr></table></figure><p>调用了buf的nioBufferCount（）方法，来获取需要发送的ByteBuffer数组个数。nioBufferCount（）方法必须在调用了nioBuffers（）之后才可以调用。</p><p>进入条件语句之后，若需要发送的ByteBuffer为0，则说明无消息需要发送，但是可能会有别的事情需要处理，所以调用了doWrite0，并将自旋减去其返回的数值。<br>当需要发送的ByteBuffer个数为1，则直接取数组内的第一个ByteBuffer去发送，然后是获取缓冲区剩余的可写字节数赋值给attemptedBytes。在调用了SocketChannel的write（）方法之后，方法会返回写入SocketChannel的字节数，判断写入的字节数，小于等于0说明TCP缓冲区已经满了，很肯能无法在继续写入，因此从循环中挑出，同时调用incompleteWrite（true）将写半包标识设置为true，用于向多路复用器注册写操作位，告诉多路复用器有没有发送完的半包消息，需要轮训出就绪的SocketChannel继续发送。<br>在处理完这些事情之后，ChannelOutbountBuffer的该部分缓冲区已经使用完毕了，于是会调用ChannelOutboundBuffer的清除方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in.removeBytes(localWrittenBytes);</span><br></pre></td></tr></table></figure><p>参数是之前写入SocketChannel的字节数。来看一下他的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void removeBytes(long writtenBytes) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        Object msg &#x3D; current();</span><br><span class="line">        if (!(msg instanceof ByteBuf)) &#123;</span><br><span class="line">            assert writtenBytes &#x3D;&#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        final ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        final int readerIndex &#x3D; buf.readerIndex();</span><br><span class="line">        final int readableBytes &#x3D; buf.writerIndex() - readerIndex;</span><br><span class="line">        if (readableBytes &lt;&#x3D; writtenBytes) &#123;</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                progress(readableBytes);</span><br><span class="line">                writtenBytes -&#x3D; readableBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            remove();</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; readableBytes &gt; writtenBytes</span><br><span class="line">            if (writtenBytes !&#x3D; 0) &#123;</span><br><span class="line">                buf.readerIndex(readerIndex + (int) writtenBytes);</span><br><span class="line">                progress(writtenBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       clearNioBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，首先是从当前ChannelOutBoundBuffer弹出第一条发送的ByteBuf，然后获取读索引和可读字节数（可读字节数 = 写索引 - 读索引），<br>将可读字节数与已经发送的字节数进行比较，可读字节数小于等于已发送字节数说明当前的bytebuf已经完全被发送出去了，那么就更新ChannelOutboundBuffer的发送进度信息以及将写指针前移，然后清空该部分内存空间。若可读字节数大于已写出字节数，说明出现了半包问题，那就需要更新可读索引，将将读索引后移writtenBytes个位置，这样当下次轮询到的时候就会重新从正确的读索引处重新开始读取消息，然后也是更新ChannelOutboundBuffer的发送进度信息。</p><p>好了，Channel的部分源码解读到这就差不多了，由于篇幅限制，Channel的Unsafe就不再这里继续展开了，笔者会另开一章来专门介绍Unsafe的源码，敬请期待吧。</p><p>谢谢阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Channel&quot;&gt;&lt;a href=&quot;#什么是Channel&quot; class=&quot;headerlink&quot; title=&quot;什么是Channel&quot;&gt;&lt;/a&gt;什么是Channel&lt;/h3&gt;&lt;p&gt;Channel（当然是Netty自己抽象的Channel）是netty的网络</summary>
      
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
  </entry>
  
</feed>
