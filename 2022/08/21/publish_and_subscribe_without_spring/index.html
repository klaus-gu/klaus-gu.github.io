<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="解耦Spring之后该如何高效的进行事件通知Spring 作为重量级生产级的框架，在日常的企业开发过程中被广泛应用，其提供的 IOC ，AOP ，WebMVC等给开发带来了极大的便利。但在使用的过程中，逐渐会发现，随着开发迭代的不断深入，Spring 逐渐变成了开发过程中不可缺少的一个环节，Spri"/>
    

    <!--Author-->
    
        <meta name="author" content="klaus_turbo"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="解耦Spring之后该如何高效的进行事件通知"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="解耦Spring之后该如何高效的进行事件通知Spring 作为重量级生产级的框架，在日常的企业开发过程中被广泛应用，其提供的 IOC ，AOP ，WebMVC等给开发带来了极大的便利。但在使用的过程中，逐渐会发现，随着开发迭代的不断深入，Spring 逐渐变成了开发过程中不可缺少的一个环节，Spri"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="进学致和，行方思远。"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://example.comimg/crescent-moon-149988-5530eca8bb0e4a8b92115b454a660af5.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://example.comimg/crescent-moon-149988-5530eca8bb0e4a8b92115b454a660af5.jpg"/>
    

    <!-- Title -->
    
    <title>解耦Spring之后该如何高效的进行事件通知 - 进学致和，行方思远。</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="img/sky-earth-space-working-2156-2a5a00a78a854bb7b67af4eb5495480a.jpg"/>
    

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="进学致和，行方思远。" type="application/atom+xml">
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">进学致和，行方思远。</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                主页
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                标签
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                分类
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://github.com/klaus-gu">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/crescent-moon-149988-5530eca8bb0e4a8b92115b454a660af5.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>解耦Spring之后该如何高效的进行事件通知</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by klaus_turbo on
                        
                        
                            2022-08-21
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/发布订阅模型/">#发布订阅模型</a> <a href="/tags/Reactor模式/">#Reactor模式</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/发布订阅模型/">发布订阅模型</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="解耦Spring之后该如何高效的进行事件通知"><a href="#解耦Spring之后该如何高效的进行事件通知" class="headerlink" title="解耦Spring之后该如何高效的进行事件通知"></a>解耦Spring之后该如何高效的进行事件通知</h1><p>Spring 作为重量级生产级的框架，在日常的企业开发过程中被广泛应用，其提供的 IOC ，AOP ，WebMVC等给开发带来了极大的便利。但在使用的过程中，逐渐会发现，随着开发迭代的不断深入，Spring 逐渐变成了开发过程中不可缺少的一个环节，Spring 所提供的类，方法在项目中遍地都是。慢慢的，框架的使用似乎逐渐成了业务逻辑一部分，想要脱离 Spring 变得及其的困难，甚至可行性变成了零。不光如此，相信很多做过框架升级的伙伴也发现了其中难以察觉的坑，一旦某一个版本出现不确定，项目就可能直接运行失败。等等诸如此类的问题，不得不思考，Spring 真的这么需要吗？（后续会有关于 简单实现一个 Spring 的分享出来，知己知彼，方能百战不殆）</p>
<p>参考很多框架中间件的实现，就不难发现，基本很少有中间件会在实现的时候直接去使用 Spring ，而是在通过后续的开发，独立出一个专门用于适配Spring的版本。我想作为这些中间件的开发创作者也大都有上面类似的顾虑吧，还有就是 Spring 的启动时间确实是难以接受，对于一些需要快速启动，低故障恢复时延的项目，Spring的接入启动好像并不是很能让人满意。</p>
<p>好了，说了这么多拙见，似乎离我们的标题越来越远了…言归正传，Spring大家既然都用过了，那它的事件通知应该也都用过的吧。不知道有没有发现一个问题，就是当你使用 ApplicationPublisher 的时候，你首先得知道这个事件是通过谁发送出去的，然后接收者得知道自己接受的是什么事件。但是我们所用的事件通知，所关注的本身是事件，对于接收者来说没有一点问题，但是要把一个事件发送出去，我们得先知道知道发送者是谁，是不是觉得有些奇怪？那要是当事件多了之后呢？</p>
<p>我们希望的是，既然是使用的事件通知这么一个东西，那么在开发的时候我想关注的只是事件本身，并不希望使用一个事件，就要显示的再去使用这个事件的发送者，同时回到我们前面说的，如果不使用 Spring ，那我们该怎么去实现事件通知呢？</p>
<p>可能有熟悉GOF23的小伙伴会脱口而出：观察者模式。没错，最根本额设计实现思想就是观察者模式，再结合我们前面说到的，要在使用的时候只关注事件本身，而不需要知道什么事件由什么发送者发出的，来看看我是怎么实现的。</p>
<p>事件通知的三板斧我们先定义好：事件，发送者，订阅者。</p>
<p>首先是事件的定义，我们使用一个标记类去定义这个事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Event implements Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件基类定义好了之后我们去定义事件的发送者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public interface EventPublisher extends Closeable &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义好当前$&#123;@link EventPublisher&#125;发送的是什么类型的事件.</span><br><span class="line">     * @return &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Class&lt;? extends Event&gt; getEventType();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 给当前的发布者添加对其发布事件感兴趣的订阅者（通过一个订阅者列表实现事件广播）.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addSubscriber(Subscriber subscriber);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从订阅者列表中删除一个订阅者.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void removeSubscriber(Subscriber subscriber);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     *</span><br><span class="line">     * @param event &#123;@link Event&#125;</span><br><span class="line">     * @return publish event is success</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean publish(Event event);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Notify listener.</span><br><span class="line">     *</span><br><span class="line">     * @param subscriber &#123;@link Subscriber&#125;</span><br><span class="line">     * @param event      &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void notifySubscriber(Subscriber subscriber, Event event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义这个事件的订阅者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subscriber&lt;T extends Event&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 事件通知的回调.</span><br><span class="line">     *</span><br><span class="line">     * @param event &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void onEvent(T event);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前订阅者所关注的事件类型.</span><br><span class="line">     *</span><br><span class="line">     * @return Class which extends &#123;@link Event&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract Class&lt;? extends Event&gt; subscribeType();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理事件的线程池（用于提高订阅者事件的处理能力）.</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@link Executor&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Executor executor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就定义好了事件，发布者，订阅者三个角色的基类。通过我们定义的 EventPublisher 来对 Event 事件进行发布，同时再运行的时候再把 Subscriber 通过 EventPublisher 中定义的 addSubscriber 方法注册到对应的 EventPublisher 中的订阅者列表中去，这样基本的观察者模式就成型了，同时，由于我们使用的是订阅者列表，实现了订阅者和发布者之间 N：1 的映射关系，以及当事件来临时，使得广播成为了可能。</p>
<p>好了，这样问题就来了，按照现在的逻辑，那是不是在发布事件的时候还是得显示的使用事件相关的 EventPublisher 实现呢？是的，按照现在的逻辑确实需要这么做，那我们怎么去解决这个问题呢？</p>
<p>既然说我们不想每次在发布一个事件的时候就要去显示的声明当前事件的发布者，那我们是不是可以想办法，在一个中转站把事件和事件发布者关联起来，将他们之间的一对一的映射关系保存在其中，这样我们每次发布事件的时候就可以通过同一个中转站去发送事件，发送的时候只需要通过映射关系去找到对应的 EventPublisher 就好了。同样的，由于 Subscriber 和 Event 的映射关系也是一对一的，所以我们便可以通过中转站将 Subscriber 注册到对应的 EventPublisher 中去了，我们来看一下这个所谓的中转站如何设计实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class UnifiedNotifyCenter   &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(UnifiedNotifyCenter.class);</span><br><span class="line">    </span><br><span class="line">    private final Map&lt;String, EventPublisher&gt; publisherMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">    </span><br><span class="line">    public UnifiedNotifyCenter(Collection&lt;EventPublisher&gt; publishers) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可以在此初始化 publisherMap</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 往对应的$&#123;@link EventPublisher&#125; 中注册订阅者.</span><br><span class="line">     * @param subscriber</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void registerSubscriber(final Subscriber subscriber) &#123;</span><br><span class="line">        String topic &#x3D; subscriber.subscribeType().getCanonicalName();</span><br><span class="line">        EventPublisher publisher &#x3D; publisherMap.get(topic);</span><br><span class="line">        if (Objects.nonNull(publisher)) &#123;</span><br><span class="line">            publisher.addSubscriber(subscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     * @param event</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean publishEvent(final Event event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return publishEvent(event.getClass(), event);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;There was an exception to the message publishing : &quot;, ex);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布事件.</span><br><span class="line">     * @param eventType</span><br><span class="line">     * @param event</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean publishEvent(final Class&lt;? extends Event&gt; eventType, final Event event) &#123;</span><br><span class="line">        String topic &#x3D; eventType.getCanonicalName();</span><br><span class="line">        EventPublisher publisher &#x3D; publisherMap.get(topic);</span><br><span class="line">        if (!Objects.isNull(publisher)) &#123;</span><br><span class="line">            return publisher.publish(event);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.warn(&quot;[UnifiedNotifyCenter] There is no [&#123;&#125;] publisher for this event.&quot;, topic);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是我定义的 中转站，通过一个Hash映射 Event 和 EventPublisher ，然后把注册和事件发布的操作都委托给这里的 UnifiedNotifyCenter。这样，我们就解决了每次事件发布都需要声明事件对应发布者的问题，并将注册订阅者和事件发布的操作委托到了 UnifiedNotifyCenter 中去。同时，由于 Subscriber 必须要注册到 EventPublisher 中才能进行事件通知，若没有中间这个 UnifiedNotifyCenter ，那么将会由于 EventPublisher 必须执行的注册操作而导致 EventPublisher 与 Subscriber 耦合到一起，在引入了 UnifiedNotifyCenter 之后，解决了两者之间的必然的耦合关系。</p>
<p>由于事件与事件发布者之间的关系需要提前维护，所以我们就需要通过某种方式将两者维护起来，可以通过 JDk 自带的 ServiceLoader 去在构造函数中初始化彼此的映射关系。或者你若想在 Spring 中使用此设计，那你便可以在构造函数中通过依赖注入的方式去初始化这个映射。</p>
<p>下面以 JDK 的ServiceLoader 为例，展示一下如何通过 ServiceLoader 去初始化：</p>
<p>首先为了方便演示，我们先定义一个通用的 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class GeneralEvent extends Event&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再定一个发送此类事件的发布者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GeneralEventPublisher extends BaseEventPublisher &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;? extends Event&gt; getEventType() &#123;</span><br><span class="line">        return GeneralEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然要使用 JDK 的ServiceLoader， 那我们要先在 resouces 的META-INF.services 下面新建一个用于查找的文档，名称为我们的 EventPublisher 基类：</p>
<p>com.example.demo.event.publisher.EventPublisher</p>
<p>其中我们在文档中定义我们的 GeneralEventPublisher ：</p>
<p>com.example.demo.event.publisher.GeneralEventPublisher</p>
<p>最后，我们在 UnifiedNotifyCenter 的无参构造函数中通过 ServiceLoader 去加载并初始化映射关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public UnifiedNotifyCenter() &#123;</span><br><span class="line">       ServiceLoader&lt;EventPublisher&gt; eventPublisherServiceLoader &#x3D; ServiceLoader.load(EventPublisher.class);</span><br><span class="line">       for (EventPublisher publisher : eventPublisherServiceLoader) &#123;</span><br><span class="line">           System.out.println( publisher.getEventType().getCanonicalName());</span><br><span class="line">           publisherMap.putIfAbsent(publisher.getEventType().getCanonicalName(), publisher);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 用于资源回收</span><br><span class="line">       Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">           if (!publisherMap.isEmpty()) &#123;</span><br><span class="line">               publisherMap.forEach((key, value) -&gt; value.shutdown());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们的一整套的时间通知机制就完成了。</p>
<p>为了解决事件多的时候事件处理时间的问题，我们可以采用一种类似 Reactor 模式的方式，在事件发布者内部维护一个监听线程，以及一个用于缓冲的队列，将事件产生的线程和事件分发的线程解耦开。同时，我们在前面定义 Subscriber 的时候，定义了一个 executor() 方法用于获取定义好的处理事件的线程池，来看看我是如何定义这么一个 类 Reactor模式的事件发布者的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WorkerBasedEventPublisher extends Thread implements EventPublisher &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(WorkerBasedEventPublisher.class);</span><br><span class="line">    </span><br><span class="line">    private final ConcurrentHashSet&lt;Subscriber&gt; subscribers &#x3D; new ConcurrentHashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private final BlockingQueue&lt;Event&gt; queue &#x3D; new ArrayBlockingQueue&lt;&gt;(1024);</span><br><span class="line">    </span><br><span class="line">    private volatile boolean shutdown &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public WorkerBasedEventPublisher() &#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ConcurrentHashSet&lt;Subscriber&gt; getSubscribers() &#123;</span><br><span class="line">        return subscribers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void addSubscriber(Subscriber subscriber) &#123;</span><br><span class="line">        subscribers.add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void removeSubscriber(Subscriber subscriber) &#123;</span><br><span class="line">        subscribers.remove(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean publish(Event event) &#123;</span><br><span class="line">        boolean success &#x3D; this.queue.offer(event);</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            System.out.println(&quot;添加发布时间失败&quot;);</span><br><span class="line">            LOGGER.warn(&quot;[WorkerBasedEventPublisher # publish] Error to publish event : [&#123;&#125;]&quot;,event.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notifySubscriber(Subscriber subscriber, Event event) &#123;</span><br><span class="line">        </span><br><span class="line">        LOGGER.debug(&quot;[ UnifiedNotifyCenter ] the &#123;&#125; will received by &#123;&#125;&quot;, event, subscriber);</span><br><span class="line">        final Runnable job &#x3D; () -&gt; subscriber.onEvent(event);</span><br><span class="line">        </span><br><span class="line">        final Executor executor &#x3D; subscriber.executor();</span><br><span class="line">        </span><br><span class="line">        if (executor !&#x3D; null) &#123;</span><br><span class="line">            executor.execute(job);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                job.run();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOGGER.error(&quot;Event callback exception: &quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        openEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void openEventHandler() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int waitTimes &#x3D; 60;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                if (shutdown || hasSubscriber() || waitTimes &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 防止 CPU 空转</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                waitTimes--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                if (shutdown) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                final Event event &#x3D; queue.take();</span><br><span class="line">                receiveEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;Event listener exception : &quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void receiveEvent(Event event) &#123;</span><br><span class="line">        if (!hasSubscriber()) &#123;</span><br><span class="line">            LOGGER.warn(&quot;[NotifyCenter] the &#123;&#125; is lost, because there is no subscriber.&quot;, event.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            notifySubscriber(subscriber, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean hasSubscriber() &#123;</span><br><span class="line">        return CollectionUtils.isNotEmpty(subscribers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        this.shutdown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 这边只是简单的将事件队列清空了，其实可以在调用销毁的钩子的时候将事件处理结束，当&#x2F;&#x2F; 然这需要看具体的业务需求</span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当需要提高处理事件的能力的时候我们就可以直接继承 WorkerBasedEventPublisher 这个事件发布者了。</p>
<p>好了，至此一个属于我们自己的发布订阅模型就实现结束了，在使用的时候我们只需要做如下几步：</p>
<ol>
<li>定义好事件</li>
<li>根据需求选择合适的 EventPublisher 定义好事件发布者</li>
<li>定义好事件订阅者</li>
<li>将事件订阅者通过统一通知中心注册到对应事件的发布者中去</li>
<li>通过JDK的spi或者其他的扩展机制，将事件与事件发布者的映射关系初始化到统一通知中心中去</li>
<li>通过统一通知中心发布事件</li>
</ol>
<p>当然，本篇文章虽然说的是解耦 Spring 之后事件通知如何进行，但在 Spring 项目中我们也是可以使用这个发布订阅模型的实现的。</p>
<p>关于事件通知实现的内容讲到这里就结束了，肯定还有更好的实现方式存在，这不重要，重要的是你是否有想法，是否有跳出框架后该怎么做的想法。</p>
<p>好的，谢谢您花了很多时间看完这篇文章，有建议的欢迎一起来探讨。</p>
<p>本人关于图片作品版权的声明：</p>
<ol>
<li><p>本人在此刊载的原创作品，其版权归属本人所有。</p>
</li>
<li><p>任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。</p>
</li>
<li><p>传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。</p>
</li>
<li><p>对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。</p>
</li>
</ol>
<p>特此声明，敬请合作。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klaus-gu" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:guyue375@outlook.com" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2022 klaus_turbo<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>